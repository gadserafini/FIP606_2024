[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FIP606 - Análise e visualização de dados em Fitopatologia",
    "section": "",
    "text": "Esta página foi criada em Quarto Markdown, com o intuito de organiza o material das aulas em tópicos que sejam intuitivos a qualquer pessoa. Convido você a explorar o site e aprender sobre o fascinante mundo da análise de dados.\n\n\nGabriel A. D. Serafini é graduado em Agronomia pelo Instituto Federal de Educação, Ciência e Tecnologia do Espírito Santo - Campus Santa Teresa (2017). Atualmente doutorando em Fitotecnia (2023), com ênfase em Agricultura Digital pelo Departamento de Fitotecnia da Universidade Federal de Viçosa - UFV, onde também obteve o título de Mestre em Fitotecnia (2020), tendo como foco de seus estudos o Melhoramento de Plantas. Além disso, realizou especialização em Inteligência Artificial e Computacional (2022) pelo Departamento de Engenharia Elétrica da mesma instituição.\n\n  \n \n \n  \n   \n  \n    \n     Lattes\n  \n  \n    \n     ORCID\n  \n  \n    \n     Email\n  \n\n\n\n\n\n\nA disciplina de FIP606 - Análise e visualização de dados em Fitopatologia do Programa de Pós-graduação em Fitopatologia da UFV, foi ministrada pelo Professor Emerson Del Ponte no primeiro semestre letivo do ano de 2024.\nEmbora direcionada a pós-graduandos em Fitopatologia, os princípios e métodos abordados são aplicáveis a outras áreas do conhecimento que lidam com dados e problemas similares. A disciplina capacita os estudantes a conduzir todas as etapas da pesquisa científica, desde o planejamento e coleta de dados até a análise e comunicação dos resultados, utilizando o ambiente computacional.\nA disciplina é ensinada na linguagem de programação atualmente mais utilizada pela comunidade científica, a linguagem R . Para isso, utiliza do ambiente de desenvolvimento integrado (IDE) RStudio, seguindo a filosofia do tidyverse e gerando propts reproduzíveis em Quarto Markdown.\n\n\n\nNesta disciplina foi utilizada a apostila da disciplina, disponibilizada pelo Porf. Emerson Del Ponte como literatura principal. Esta apostila, foi produzida em R Markdown e utilizando o pacote bookdown para geração no formato gitbook, é uma ferramenta completa, intuitiva e de fácil compreensão, combinando textos e códigos em R, com a programação ensinada no IDE RStudio seguindo a filosofia do tidyverse. Esta apostila é ideal para iniciantes, oferecendo uma abordagem clara e acessível para quem deseja aprender análise de dados usando R.\nRecomendo também o livro “R para Data Science” de Hadley Wickham e Garrett Grolemund, caso deseje aprofundar os conhecimentos em ciência de dados com R. Este livro é robusto e detalhado, abrangendo desde a importação e limpeza de dados até a visualização e modelagem, utilizando também os pacotes do tidyverse. Com uma abordagem prática e acessível, ele é ideal tanto para iniciantes quanto para aqueles com alguma experiência.\nOutra recomendação é o livro “Estatística Prática para Cientistas de Dados” de Peter Bruce e Andrew Bruce, um livro consiso mas de leitura essencial para quem busca compreender e aplicar conceitos estatísticos no campo da ciência de dados. Este livro oferece uma abordagem prática e acessível utilizando o R como forma de ensino, tornando a estatística intuitiva e fácil de entender para profissionais de todas as áreas. Ele cobre tópicos fundamentais como distribuição de dados, inferência estatística, testes de hipóteses, regressão e análise de variância, com exemplos claros e exercícios práticos no R."
  },
  {
    "objectID": "index.html#sobre-o-autor",
    "href": "index.html#sobre-o-autor",
    "title": "FIP606 - Análise e visualização de dados em Fitopatologia",
    "section": "",
    "text": "Gabriel A. D. Serafini é graduado em Agronomia pelo Instituto Federal de Educação, Ciência e Tecnologia do Espírito Santo - Campus Santa Teresa (2017). Atualmente doutorando em Fitotecnia (2023), com ênfase em Agricultura Digital pelo Departamento de Fitotecnia da Universidade Federal de Viçosa - UFV, onde também obteve o título de Mestre em Fitotecnia (2020), tendo como foco de seus estudos o Melhoramento de Plantas. Além disso, realizou especialização em Inteligência Artificial e Computacional (2022) pelo Departamento de Engenharia Elétrica da mesma instituição.\n\n  \n \n \n  \n   \n  \n    \n     Lattes\n  \n  \n    \n     ORCID\n  \n  \n    \n     Email"
  },
  {
    "objectID": "index.html#sobre-a-disciplina",
    "href": "index.html#sobre-a-disciplina",
    "title": "FIP606 - Análise e visualização de dados em Fitopatologia",
    "section": "",
    "text": "A disciplina de FIP606 - Análise e visualização de dados em Fitopatologia do Programa de Pós-graduação em Fitopatologia da UFV, foi ministrada pelo Professor Emerson Del Ponte no primeiro semestre letivo do ano de 2024.\nEmbora direcionada a pós-graduandos em Fitopatologia, os princípios e métodos abordados são aplicáveis a outras áreas do conhecimento que lidam com dados e problemas similares. A disciplina capacita os estudantes a conduzir todas as etapas da pesquisa científica, desde o planejamento e coleta de dados até a análise e comunicação dos resultados, utilizando o ambiente computacional.\nA disciplina é ensinada na linguagem de programação atualmente mais utilizada pela comunidade científica, a linguagem R . Para isso, utiliza do ambiente de desenvolvimento integrado (IDE) RStudio, seguindo a filosofia do tidyverse e gerando propts reproduzíveis em Quarto Markdown."
  },
  {
    "objectID": "index.html#literaturas-de-apoio",
    "href": "index.html#literaturas-de-apoio",
    "title": "FIP606 - Análise e visualização de dados em Fitopatologia",
    "section": "",
    "text": "Nesta disciplina foi utilizada a apostila da disciplina, disponibilizada pelo Porf. Emerson Del Ponte como literatura principal. Esta apostila, foi produzida em R Markdown e utilizando o pacote bookdown para geração no formato gitbook, é uma ferramenta completa, intuitiva e de fácil compreensão, combinando textos e códigos em R, com a programação ensinada no IDE RStudio seguindo a filosofia do tidyverse. Esta apostila é ideal para iniciantes, oferecendo uma abordagem clara e acessível para quem deseja aprender análise de dados usando R.\nRecomendo também o livro “R para Data Science” de Hadley Wickham e Garrett Grolemund, caso deseje aprofundar os conhecimentos em ciência de dados com R. Este livro é robusto e detalhado, abrangendo desde a importação e limpeza de dados até a visualização e modelagem, utilizando também os pacotes do tidyverse. Com uma abordagem prática e acessível, ele é ideal tanto para iniciantes quanto para aqueles com alguma experiência.\nOutra recomendação é o livro “Estatística Prática para Cientistas de Dados” de Peter Bruce e Andrew Bruce, um livro consiso mas de leitura essencial para quem busca compreender e aplicar conceitos estatísticos no campo da ciência de dados. Este livro oferece uma abordagem prática e acessível utilizando o R como forma de ensino, tornando a estatística intuitiva e fácil de entender para profissionais de todas as áreas. Ele cobre tópicos fundamentais como distribuição de dados, inferência estatística, testes de hipóteses, regressão e análise de variância, com exemplos claros e exercícios práticos no R."
  },
  {
    "objectID": "aula_04.html",
    "href": "aula_04.html",
    "title": "Visualização de dados, outras abordagens",
    "section": "",
    "text": "A visualização de dados é essencial para entender e comunicar padrões e insights, existindo inúmeras possíbilidades de importação de dados. Agora iremos explorar outras técnicas e pacotes no R que facilitam a importação e visualização de datasets.\n\n\nUma das formas é a concatenação de dados de forma manual os atribuindo a um objeto. Para isso podemos utilizar a função nativa c() que concatena os dados, separados por vírgula.\n\ncomp &lt;- c(\"9\", \"12.5\", \"10\", \"8\", \"13.2\", \"11\", \"10.8\", \"9.5\", \"10.8\", \"10.4\", \"13.72\", \"15.91\", \"15.7\", \"14.2\", \"15.9\", \"16.54\", \"18\", \"14.4\", \"16.41\", \"16\")\ncomp\n\n [1] \"9\"     \"12.5\"  \"10\"    \"8\"     \"13.2\"  \"11\"    \"10.8\"  \"9.5\"   \"10.8\" \n[10] \"10.4\"  \"13.72\" \"15.91\" \"15.7\"  \"14.2\"  \"15.9\"  \"16.54\" \"18\"    \"14.4\" \n[19] \"16.41\" \"16\"   \n\ncomp &lt;- c(9, 12.5, 10, 8, 13.2, 11, 10.8, 9.5, 10.8, 10.4, 13.72, 15.91, 15.7, 14.2, 15.9, 16.54, 18, 14.4, 16.41, 16)\ncomp\n\n [1]  9.00 12.50 10.00  8.00 13.20 11.00 10.80  9.50 10.80 10.40 13.72 15.91\n[13] 15.70 14.20 15.90 16.54 18.00 14.40 16.41 16.00\n\n\nTambém podemos utilizar o pacote datapasta, que permite copiar dados de qualquer lugar e colar diretamente no R como uma tibble.\n\nlibrary(datapasta)\nvisitas &lt;- tibble::tribble(\n             ~`codigo`,          ~país, ~`n2`,\n             1L,     \"Brazil\",      4303L,\n               2L,     \"Mozambique\",      43L,\n               3L,       \"Portugal\",      33L,\n               4L,  \"United States\",      23L,\n               5L,         \"Angola\",      19L,\n               6L,          \"Spain\",      16L,\n               7L,      \"(not set)\",      12L,\n               8L,       \"Colombia\",       8L,\n               9L,        \"Germany\",       5L,\n              10L,        \"Hungary\",       5L,\n              11L, \"United Kingdom\",       5L,\n              12L,    \"Netherlands\",       4L,\n              13L,        \"Ecuador\",       3L,\n              14L,         \"France\",       3L,\n              15L,          \"Chile\",       2L,\n              16L,       \"Paraguay\",       2L,\n              17L,           \"Peru\",       2L,\n              18L,      \"Argentina\",       1L,\n              19L,        \"Austria\",       1L,\n              20L,        \"Bolivia\",       1L,\n              21L,     \"Cape Verde\",       1L,\n              22L,          \"China\",       1L,\n              23L,          \"Egypt\",       1L,\n              24L,        \"Finland\",       1L,\n              25L,          \"India\",       1L,\n              26L,          \"Italy\",       1L,\n              27L,       \"Malaysia\",       1L,\n              28L,       \"Pakistan\",       1L,\n              29L,         \"Poland\",       1L,\n              30L,      \"Singapore\",       1L,\n              31L,    \"Timor-Leste\",       1L,\n              32L,        \"Uruguay\",       1L\n             )\nhead(visitas)\n\n# A tibble: 6 × 3\n  codigo país             n2\n   &lt;int&gt; &lt;chr&gt;         &lt;int&gt;\n1      1 Brazil         4303\n2      2 Mozambique       43\n3      3 Portugal         33\n4      4 United States    23\n5      5 Angola           19\n6      6 Spain            16\n\n\n\n\n\nO pacote pak permite que os dados sejam baixados de outros repositórios. Para isso, inicialmente precisamos instalar o pacote.\n\n#install.packages(\"pak\")\n\nAgora, poderemos instalar pacotes de outros repositórios, como o Icens, que será utilizado em outros tópicos. Muitos destes pacotes contem datasets que podem ser utilizados para testes de funções.\n\n#pak::pkg_install(\"Icens\")\n\nTambém podemos baixar os pacortes diretamente do github, como o pacote do Prof. Emerson, r4pde através do caminho “emdelponte/r4pde”.\n\n#pak::pkg_install(\"emdelponte/r4pde\")\n\n\n\n\nVocê pode transformar dados de formato largo para formato longo (e vice-versa) usando tidyverse. Para isso vamos praticar utilizando a função tribble, para colarmos os dados do caopítulo 10.4 do livro r4pde.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\npepper &lt;- \n  tribble(\n   ~t,  ~`1`,  ~`2`,  ~`3`,\n   0,  0.08, 0.001, 0.001,\n   7,  0.13,  0.01, 0.001,\n  14,  0.78,  0.09,  0.01,\n  21,  0.92,  0.25,  0.05,\n  28,  0.99,   0.8,  0.18,\n  35, 0.995,  0.98,  0.34,\n  42, 0.999,  0.99,  0.48,\n  49, 0.999, 0.999,  0.74\n  ) \n\n\n\nNo ggplot2, annotate é uma função usada para adicionar anotações diretamente a um gráfico. Anotações podem ser texto, formas ou outras marcas visuais que ajudam a destacar ou explicar partes específicas do gráfico.\nA função annotate permite que você adicione elementos como texto, segmentos, retângulos e outros tipos de geometrias ao seu gráfico. Isso é útil para chamar a atenção para pontos específicos, adicionar rótulos personalizados ou destacar áreas de interesse.\nAproveitando o exemplo anterior, podemos inserir textos no gráfico fornecendo as coordenadas dos textos no mapa. Por exemplo, podemos adicionar os valores dos tratamentos para cada curva:\n\nlibrary(ggplot2)\npepper |&gt; \n  pivot_longer(2:4,\n               names_to = \"epidemic\",\n               values_to = \"inc\") |&gt; \n  ggplot(aes(t, inc, color = epidemic))+\n  geom_point()+\n  geom_line()+\n  annotate(geom = \"text\", x = 12, y = 0.75, label = \"1\")+\n  annotate(geom = \"text\", x = 25, y = 0.75, label = \"2\")+\n  annotate(geom = \"text\", x = 45, y = 0.75, label = \"3\")+\n  theme(legend.position = \"none\") #retirar a legenda para não ficar redundante\n\n\n\n\n\n\n\n\n\n\n\n\nAs tabelas de contingência permitem cruzar variáveis e observar suas interações. O pacote janitor facilita a criação dessas tabelas.\nPor exemplo a função count conta quantas observações existem na variável e exibe em uma tabela, podemos filtrar colocando mais variáveis.\n\ncr &lt;- read_csv(\"https://raw.githubusercontent.com/emdelponte/paper-coffee-rust-Ethiopia/master/data/survey_clean.csv\")\n\nRows: 405 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (7): region, zone, district, cultivar, shade, cropping_system, farm_mana...\ndbl (6): farm, lon, lat, altitude, inc, sev2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncr |&gt; \n  count(region, zone)\n\n# A tibble: 9 × 3\n  region zone             n\n  &lt;chr&gt;  &lt;chr&gt;        &lt;int&gt;\n1 Oromia Bale            30\n2 Oromia Ilu AbaBora     45\n3 Oromia Jimma           45\n4 Oromia West Wellega    45\n5 SNNPR  Bench Maji      45\n6 SNNPR  Gedio           45\n7 SNNPR  Keffa           45\n8 SNNPR  Sheka           45\n9 SNNPR  Sidama          60\n\n\nPodemos cruzar as variáveis usando a função de contingência tabyl para cruzarmos duas variáveis, como por exemplo:\n\nlibrary(janitor)\n\n\nAnexando pacote: 'janitor'\n\n\nOs seguintes objetos são mascarados por 'package:stats':\n\n    chisq.test, fisher.test\n\ncr |&gt; \n  tabyl(region, zone)\n\n region Bale Bench Maji Gedio Ilu AbaBora Jimma Keffa Sheka Sidama West Wellega\n Oromia   30          0     0          45    45     0     0      0           45\n  SNNPR    0         45    45           0     0    45    45     60            0\n\n\n\ncr |&gt; \n  tabyl(zone, region)\n\n         zone Oromia SNNPR\n         Bale     30     0\n   Bench Maji      0    45\n        Gedio      0    45\n  Ilu AbaBora     45     0\n        Jimma     45     0\n        Keffa      0    45\n        Sheka      0    45\n       Sidama      0    60\n West Wellega     45     0\n\n\n\ncr |&gt; \n  tabyl(cultivar, region)\n\n cultivar Oromia SNNPR\n Improved     23    60\n    Local     50    66\n  Mixture     92   114\n\n\nEsse artifício é interessante para obervações, como por exemplo, podemos observar abaixo que na cultivar melhorada só se trabalha com manejo intensivo enquanto que a cultivar local não se tem manejo, ou ele é minimo.\n\ncr |&gt; \n  tabyl(cultivar, farm_management)\n\n cultivar Intensive Minimal Moderate Unmanaged\n Improved        83       0        0         0\n    Local         0      10        4       102\n  Mixture        82      59       65         0\n\n\n\n\n\n\n\nPodemos empilhar colunas e visualizar a distribuição de categorias, para isso podemos utilizar o geom_col, como no exemplo abaixo:\n\ncr |&gt; \n  count(farm_management, cultivar) |&gt; \n  ggplot(aes(cultivar, n, fill = farm_management))+\n  geom_col()\n\n\n\n\n\n\n\n\n\n\n\nPara visualizar colunas separadas, podemos utilizar position = \"dodge2\", assim as colunas podem ser separadas por cultivares como nos exemplos abaixo.\n\ncr |&gt; \n  count(farm_management, cultivar) |&gt; \n  ggplot(aes(cultivar, n, fill = farm_management))+\n  geom_col(position = \"dodge2\")\n\n\n\n\n\n\n\n\n\nlibrary(ggthemes)\ncr |&gt; \n  count(farm_management, cultivar) |&gt; \n  ggplot(aes(cultivar, n, fill = farm_management))+\n  geom_col(position = \"dodge2\")+\n  scale_fill_calc()+\n  theme_bw()+\n  theme(strip.text.x = element_blank(),\n        legend.position = \"top\")+ #Tira o nome em cima\n  #geom_text(position = position_dodge(width = 0.9))+\n  facet_wrap(~cultivar, scales = \"free_x\")"
  },
  {
    "objectID": "aula_04.html#importando-datasets",
    "href": "aula_04.html#importando-datasets",
    "title": "Visualização de dados, outras abordagens",
    "section": "",
    "text": "Uma das formas é a concatenação de dados de forma manual os atribuindo a um objeto. Para isso podemos utilizar a função nativa c() que concatena os dados, separados por vírgula.\n\ncomp &lt;- c(\"9\", \"12.5\", \"10\", \"8\", \"13.2\", \"11\", \"10.8\", \"9.5\", \"10.8\", \"10.4\", \"13.72\", \"15.91\", \"15.7\", \"14.2\", \"15.9\", \"16.54\", \"18\", \"14.4\", \"16.41\", \"16\")\ncomp\n\n [1] \"9\"     \"12.5\"  \"10\"    \"8\"     \"13.2\"  \"11\"    \"10.8\"  \"9.5\"   \"10.8\" \n[10] \"10.4\"  \"13.72\" \"15.91\" \"15.7\"  \"14.2\"  \"15.9\"  \"16.54\" \"18\"    \"14.4\" \n[19] \"16.41\" \"16\"   \n\ncomp &lt;- c(9, 12.5, 10, 8, 13.2, 11, 10.8, 9.5, 10.8, 10.4, 13.72, 15.91, 15.7, 14.2, 15.9, 16.54, 18, 14.4, 16.41, 16)\ncomp\n\n [1]  9.00 12.50 10.00  8.00 13.20 11.00 10.80  9.50 10.80 10.40 13.72 15.91\n[13] 15.70 14.20 15.90 16.54 18.00 14.40 16.41 16.00\n\n\nTambém podemos utilizar o pacote datapasta, que permite copiar dados de qualquer lugar e colar diretamente no R como uma tibble.\n\nlibrary(datapasta)\nvisitas &lt;- tibble::tribble(\n             ~`codigo`,          ~país, ~`n2`,\n             1L,     \"Brazil\",      4303L,\n               2L,     \"Mozambique\",      43L,\n               3L,       \"Portugal\",      33L,\n               4L,  \"United States\",      23L,\n               5L,         \"Angola\",      19L,\n               6L,          \"Spain\",      16L,\n               7L,      \"(not set)\",      12L,\n               8L,       \"Colombia\",       8L,\n               9L,        \"Germany\",       5L,\n              10L,        \"Hungary\",       5L,\n              11L, \"United Kingdom\",       5L,\n              12L,    \"Netherlands\",       4L,\n              13L,        \"Ecuador\",       3L,\n              14L,         \"France\",       3L,\n              15L,          \"Chile\",       2L,\n              16L,       \"Paraguay\",       2L,\n              17L,           \"Peru\",       2L,\n              18L,      \"Argentina\",       1L,\n              19L,        \"Austria\",       1L,\n              20L,        \"Bolivia\",       1L,\n              21L,     \"Cape Verde\",       1L,\n              22L,          \"China\",       1L,\n              23L,          \"Egypt\",       1L,\n              24L,        \"Finland\",       1L,\n              25L,          \"India\",       1L,\n              26L,          \"Italy\",       1L,\n              27L,       \"Malaysia\",       1L,\n              28L,       \"Pakistan\",       1L,\n              29L,         \"Poland\",       1L,\n              30L,      \"Singapore\",       1L,\n              31L,    \"Timor-Leste\",       1L,\n              32L,        \"Uruguay\",       1L\n             )\nhead(visitas)\n\n# A tibble: 6 × 3\n  codigo país             n2\n   &lt;int&gt; &lt;chr&gt;         &lt;int&gt;\n1      1 Brazil         4303\n2      2 Mozambique       43\n3      3 Portugal         33\n4      4 United States    23\n5      5 Angola           19\n6      6 Spain            16"
  },
  {
    "objectID": "aula_04.html#instalando-pacotes-de-outros-repositórios",
    "href": "aula_04.html#instalando-pacotes-de-outros-repositórios",
    "title": "Visualização de dados, outras abordagens",
    "section": "",
    "text": "O pacote pak permite que os dados sejam baixados de outros repositórios. Para isso, inicialmente precisamos instalar o pacote.\n\n#install.packages(\"pak\")\n\nAgora, poderemos instalar pacotes de outros repositórios, como o Icens, que será utilizado em outros tópicos. Muitos destes pacotes contem datasets que podem ser utilizados para testes de funções.\n\n#pak::pkg_install(\"Icens\")\n\nTambém podemos baixar os pacortes diretamente do github, como o pacote do Prof. Emerson, r4pde através do caminho “emdelponte/r4pde”.\n\n#pak::pkg_install(\"emdelponte/r4pde\")"
  },
  {
    "objectID": "aula_04.html#transformando-formatos-com-tidyverse",
    "href": "aula_04.html#transformando-formatos-com-tidyverse",
    "title": "Visualização de dados, outras abordagens",
    "section": "",
    "text": "Você pode transformar dados de formato largo para formato longo (e vice-versa) usando tidyverse. Para isso vamos praticar utilizando a função tribble, para colarmos os dados do caopítulo 10.4 do livro r4pde.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\npepper &lt;- \n  tribble(\n   ~t,  ~`1`,  ~`2`,  ~`3`,\n   0,  0.08, 0.001, 0.001,\n   7,  0.13,  0.01, 0.001,\n  14,  0.78,  0.09,  0.01,\n  21,  0.92,  0.25,  0.05,\n  28,  0.99,   0.8,  0.18,\n  35, 0.995,  0.98,  0.34,\n  42, 0.999,  0.99,  0.48,\n  49, 0.999, 0.999,  0.74\n  ) \n\n\n\nNo ggplot2, annotate é uma função usada para adicionar anotações diretamente a um gráfico. Anotações podem ser texto, formas ou outras marcas visuais que ajudam a destacar ou explicar partes específicas do gráfico.\nA função annotate permite que você adicione elementos como texto, segmentos, retângulos e outros tipos de geometrias ao seu gráfico. Isso é útil para chamar a atenção para pontos específicos, adicionar rótulos personalizados ou destacar áreas de interesse.\nAproveitando o exemplo anterior, podemos inserir textos no gráfico fornecendo as coordenadas dos textos no mapa. Por exemplo, podemos adicionar os valores dos tratamentos para cada curva:\n\nlibrary(ggplot2)\npepper |&gt; \n  pivot_longer(2:4,\n               names_to = \"epidemic\",\n               values_to = \"inc\") |&gt; \n  ggplot(aes(t, inc, color = epidemic))+\n  geom_point()+\n  geom_line()+\n  annotate(geom = \"text\", x = 12, y = 0.75, label = \"1\")+\n  annotate(geom = \"text\", x = 25, y = 0.75, label = \"2\")+\n  annotate(geom = \"text\", x = 45, y = 0.75, label = \"3\")+\n  theme(legend.position = \"none\") #retirar a legenda para não ficar redundante"
  },
  {
    "objectID": "aula_04.html#tabelas-de-contingência-com-janitor",
    "href": "aula_04.html#tabelas-de-contingência-com-janitor",
    "title": "Visualização de dados, outras abordagens",
    "section": "",
    "text": "As tabelas de contingência permitem cruzar variáveis e observar suas interações. O pacote janitor facilita a criação dessas tabelas.\nPor exemplo a função count conta quantas observações existem na variável e exibe em uma tabela, podemos filtrar colocando mais variáveis.\n\ncr &lt;- read_csv(\"https://raw.githubusercontent.com/emdelponte/paper-coffee-rust-Ethiopia/master/data/survey_clean.csv\")\n\nRows: 405 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (7): region, zone, district, cultivar, shade, cropping_system, farm_mana...\ndbl (6): farm, lon, lat, altitude, inc, sev2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncr |&gt; \n  count(region, zone)\n\n# A tibble: 9 × 3\n  region zone             n\n  &lt;chr&gt;  &lt;chr&gt;        &lt;int&gt;\n1 Oromia Bale            30\n2 Oromia Ilu AbaBora     45\n3 Oromia Jimma           45\n4 Oromia West Wellega    45\n5 SNNPR  Bench Maji      45\n6 SNNPR  Gedio           45\n7 SNNPR  Keffa           45\n8 SNNPR  Sheka           45\n9 SNNPR  Sidama          60\n\n\nPodemos cruzar as variáveis usando a função de contingência tabyl para cruzarmos duas variáveis, como por exemplo:\n\nlibrary(janitor)\n\n\nAnexando pacote: 'janitor'\n\n\nOs seguintes objetos são mascarados por 'package:stats':\n\n    chisq.test, fisher.test\n\ncr |&gt; \n  tabyl(region, zone)\n\n region Bale Bench Maji Gedio Ilu AbaBora Jimma Keffa Sheka Sidama West Wellega\n Oromia   30          0     0          45    45     0     0      0           45\n  SNNPR    0         45    45           0     0    45    45     60            0\n\n\n\ncr |&gt; \n  tabyl(zone, region)\n\n         zone Oromia SNNPR\n         Bale     30     0\n   Bench Maji      0    45\n        Gedio      0    45\n  Ilu AbaBora     45     0\n        Jimma     45     0\n        Keffa      0    45\n        Sheka      0    45\n       Sidama      0    60\n West Wellega     45     0\n\n\n\ncr |&gt; \n  tabyl(cultivar, region)\n\n cultivar Oromia SNNPR\n Improved     23    60\n    Local     50    66\n  Mixture     92   114\n\n\nEsse artifício é interessante para obervações, como por exemplo, podemos observar abaixo que na cultivar melhorada só se trabalha com manejo intensivo enquanto que a cultivar local não se tem manejo, ou ele é minimo.\n\ncr |&gt; \n  tabyl(cultivar, farm_management)\n\n cultivar Intensive Minimal Moderate Unmanaged\n Improved        83       0        0         0\n    Local         0      10        4       102\n  Mixture        82      59       65         0"
  },
  {
    "objectID": "aula_04.html#visualizando-dados-com-gráficos",
    "href": "aula_04.html#visualizando-dados-com-gráficos",
    "title": "Visualização de dados, outras abordagens",
    "section": "",
    "text": "Podemos empilhar colunas e visualizar a distribuição de categorias, para isso podemos utilizar o geom_col, como no exemplo abaixo:\n\ncr |&gt; \n  count(farm_management, cultivar) |&gt; \n  ggplot(aes(cultivar, n, fill = farm_management))+\n  geom_col()\n\n\n\n\n\n\n\n\n\n\n\nPara visualizar colunas separadas, podemos utilizar position = \"dodge2\", assim as colunas podem ser separadas por cultivares como nos exemplos abaixo.\n\ncr |&gt; \n  count(farm_management, cultivar) |&gt; \n  ggplot(aes(cultivar, n, fill = farm_management))+\n  geom_col(position = \"dodge2\")\n\n\n\n\n\n\n\n\n\nlibrary(ggthemes)\ncr |&gt; \n  count(farm_management, cultivar) |&gt; \n  ggplot(aes(cultivar, n, fill = farm_management))+\n  geom_col(position = \"dodge2\")+\n  scale_fill_calc()+\n  theme_bw()+\n  theme(strip.text.x = element_blank(),\n        legend.position = \"top\")+ #Tira o nome em cima\n  #geom_text(position = position_dodge(width = 0.9))+\n  facet_wrap(~cultivar, scales = \"free_x\")"
  },
  {
    "objectID": "aula_02b.html",
    "href": "aula_02b.html",
    "title": "Importando e Manipulando dados",
    "section": "",
    "text": "A importação de dados é um passo crucial na análise de dados, pois permite que você traga informações de várias fontes para dentro do ambiente R, onde podem ser limpas, manipuladas e analisadas. Com R, você pode importar dados de diversos formatos, como CSV, Excel, e até mesmo planilhas online do Google Sheets. Utilizar pacotes específicos para cada tipo de arquivo garante que os dados sejam lidos de maneira eficiente e sem erros.\n\n\nMuitas vezes, com o intuito de que o usuário possa testar algumas funções dos pacotes, estes pacotes possuem conjuntos de dados que podem ser importados ou carregados e utilizados.\nA título de ensino, vamos começar com a instalação e carregamento do pacote ec50estimator, que é utilizado para estimativas de EC50 em análises biológicas. Neste pacote, utilizaremos o conjunto de dados multi_isolate.\n\nlibrary(ec50estimator)\n\nWarning: pacote 'ec50estimator' foi compilado no R versão 4.4.1\n\nhead(multi_isolate)\n\n  isolate   field   fungicida  dose     growth\n1       1 Organic Fungicide A 0e+00 20.2082399\n2       1 Organic Fungicide A 1e-05 20.1168279\n3       1 Organic Fungicide A 1e-04 19.2479678\n4       1 Organic Fungicide A 1e-03 15.8123455\n5       1 Organic Fungicide A 1e-02  7.3206757\n6       1 Organic Fungicide A 1e-01  0.6985264\n\n\nPodemos atribuir os dados a um objeto, neste caso ao objeto df1 e usaremos a função View(df1) para abrir uma nova aba exibindo os dados. View() é particularmente útil para uma inspeção rápida dos dados em uma interface tabular.\n\ndf1 &lt;- multi_isolate\nView(df1)\n\n\n\n\nOutra opção é a importação de arquivos existentes no próprio computador do usuário, como arquivos de dados em Excel. Para a leitura e importação de dados em Excel, utilizaremos o pacote readxl, e para isso é necessário que instale e carregue este pacote.\nO pacote readxl, que permite a leitura de arquivos Excel (.xlsx). Este pacote é especialmente útil para importar dados que são frequentemente armazenados em planilhas.\nPara ler um arquivo Excel na pasta do projeto, use o comando read_excel(\"nome_do_arquivo.xlsx\"), caso o arquivo esteja em outra pasta é necessário colocar, dentro dos parênteses, o caminho do arquivo antes do nome.\nSe você precisar abrir uma planilha específica, como “escala”, utilize o argumento sheet. O segundo argumento é um parâmetro opcional, podendo ser o nome da aba ou apenas o número da aba sem aspas.\n\nlibrary(readxl)\ndf2 &lt;- read_excel(\"dados-diversos.xlsx\")\ndf21 &lt;- read_excel(\"dados-diversos.xlsx\", sheet = \"escala\")\n#Outras formas de abri e/ou atribuir abas específicas\n#df21 &lt;- read_excel(\"dados-diversos.xlsx\", \"escala\")\n#df21 &lt;- read_excel(\"dados-diversos.xlsx\", 2)\n\n\n\n\nOutra opção, para arquivos CSV, é a utilização do pacote tidyverse, uma coleção de pacotes R para ciência de dados, incluindo readr para leitura de arquivos CSV. O tidyverse simplifica e uniformiza várias operações de manipulação de dados.\nNeste caso utilizamos a função read_csv``(\"nome_do_arquivo.xlsx\"), lembrando que, caso o arquivo esteja em outra pasta é necessário colocar o caminho do arquivo antes do nome.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndf3 &lt;- read_csv(\"dados-diversos.csv\")\n\nRows: 60 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Irrigation\ndbl (3): rep, day, severity\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\nAtualmente a utilização de drives em nuvem para salvar bancos de dados está amplamente difundida Isso é devido a facilidade de acesso aos dados, que pode ser feita de qualquer dispositivo, desde que se tenha acesso a internet.\nPara utilizar um banco de dados diretamente do Google Drive, por exemplo, pode-se utilizar os pacotes gsheet e googlesheets4. O pacote gsheet permite a leitura rápida de Google Sheets usando URLs, enquanto o googlesheets4 oferece funcionalidade mais abrangente para leitura e escrita em Google Sheets.\nNo caso do pacote gsheet, a função utilizada para abrir e importar dados de arquivos no Google Drive é o gsheet2tbl(``\"link_do_arquivo\").\n\nlibrary(gsheet)\ndf4 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137\")\n\ndf41 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?usp=drive_link&ouid=104144100918915406194&rtpof=true&sd=true\", sheetid = \"3\")\n\nPara o pacote googlesheets4, o nome da função é read_sheet``(\"link_do_arquivo\"). Ele permite não somente baixar, mas ele permite também escrever nos arquivos.\nlibrary(googlesheets4) df5 &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\")\n\n\n\nPara criar gráficos para análise exploratória das variáveis, utilizaremos o ggplot2, um dos pacotes mais populares do R para visualização de dados. A função geom_point mostra os pontos de uma variável, mas pode ocorrer destes pontos estarem sobrepostos, assim pode-se utilizar a função geom_jitter para desagregar os pontos.\nPodemos adicionar camadas com o operador +, como geom_boxplot. A ordem das camadas determina como elas serão exibidas: a primeira camada chamada fica na parte inferior e as subsequentes são empilhadas acima.\nPara evitar duplicação de outliers, utilize outlier.colour = NA.\nTemas específicos também podem ser aplicados, como theme_bw() para um visual preto e branco utilizado em artigos cientificos, ou theme_classic.\n\nlibrary(ggplot2)\ng1 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_point(color = \"red\", shape = 2, size = 3)\ng1 + theme_classic()+\n  labs(x = \"Tratamento\", #Label do eixo x\n       y = \"Comprimento\", #Label do eixo y\n       title = \"Meu primeiro ggplot\", #Adiciona título ao gráfico\n       caption = \"Fonte: Dados diversos\") #Adiciona fonte ao gráfico\n\n\n\n\n\n\n\ng2 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_boxplot(outlier.colour = NA,\n               fill = \"green\")+\n  geom_jitter(width = 0.05,\n              color = \"blue\",\n              shape = 3,\n              size = 2)\ng2 + theme_bw() +\n  #ylim(0,20) #Outra opção para a função abaixo\n  scale_y_continuous(limits = c(0,20),\n                     n.breaks = 5) #n.breaks é o número de quebras, se colocar breaks apenas, fica só a linha correspondente aquele número.\n\n\n\n\n\n\n\n\nApós a criação do gráfico, através do pacote ggplot2, podemos salvar os gráficos utilizando a função ggsave. A função ggsave é usada para salvar gráficos criados com ggplot2 em diferentes formatos de arquivo, como PNG, PDF, JPEG, entre outros. Isso é útil para documentar visualizações, compartilhar resultados ou incluir gráficos em relatórios e apresentações.\n\nggsave(\"plot1.png\", bg = \"white\") #O parâmetro \"bg\" é a cor de fundo ou \"background\"\n\nSaving 7 x 5 in image\n\n\nEntendendo esses passos, você será capaz de importar dados de diversas fontes, realizar manipulações e criar visualizações ricas utilizando R e seus pacotes associados. Cada pacote desempenha um papel crucial na simplificação e eficiência das suas tarefas de análise de dados."
  },
  {
    "objectID": "aula_02b.html#importando-dados-de-pacotes",
    "href": "aula_02b.html#importando-dados-de-pacotes",
    "title": "Importando e Manipulando dados",
    "section": "",
    "text": "Muitas vezes, com o intuito de que o usuário possa testar algumas funções dos pacotes, estes pacotes possuem conjuntos de dados que podem ser importados ou carregados e utilizados.\nA título de ensino, vamos começar com a instalação e carregamento do pacote ec50estimator, que é utilizado para estimativas de EC50 em análises biológicas. Neste pacote, utilizaremos o conjunto de dados multi_isolate.\n\nlibrary(ec50estimator)\n\nWarning: pacote 'ec50estimator' foi compilado no R versão 4.4.1\n\nhead(multi_isolate)\n\n  isolate   field   fungicida  dose     growth\n1       1 Organic Fungicide A 0e+00 20.2082399\n2       1 Organic Fungicide A 1e-05 20.1168279\n3       1 Organic Fungicide A 1e-04 19.2479678\n4       1 Organic Fungicide A 1e-03 15.8123455\n5       1 Organic Fungicide A 1e-02  7.3206757\n6       1 Organic Fungicide A 1e-01  0.6985264\n\n\nPodemos atribuir os dados a um objeto, neste caso ao objeto df1 e usaremos a função View(df1) para abrir uma nova aba exibindo os dados. View() é particularmente útil para uma inspeção rápida dos dados em uma interface tabular.\n\ndf1 &lt;- multi_isolate\nView(df1)"
  },
  {
    "objectID": "aula_02b.html#leitura-e-importação-de-dados-de-arquivos-excel",
    "href": "aula_02b.html#leitura-e-importação-de-dados-de-arquivos-excel",
    "title": "Importando e Manipulando dados",
    "section": "",
    "text": "Outra opção é a importação de arquivos existentes no próprio computador do usuário, como arquivos de dados em Excel. Para a leitura e importação de dados em Excel, utilizaremos o pacote readxl, e para isso é necessário que instale e carregue este pacote.\nO pacote readxl, que permite a leitura de arquivos Excel (.xlsx). Este pacote é especialmente útil para importar dados que são frequentemente armazenados em planilhas.\nPara ler um arquivo Excel na pasta do projeto, use o comando read_excel(\"nome_do_arquivo.xlsx\"), caso o arquivo esteja em outra pasta é necessário colocar, dentro dos parênteses, o caminho do arquivo antes do nome.\nSe você precisar abrir uma planilha específica, como “escala”, utilize o argumento sheet. O segundo argumento é um parâmetro opcional, podendo ser o nome da aba ou apenas o número da aba sem aspas.\n\nlibrary(readxl)\ndf2 &lt;- read_excel(\"dados-diversos.xlsx\")\ndf21 &lt;- read_excel(\"dados-diversos.xlsx\", sheet = \"escala\")\n#Outras formas de abri e/ou atribuir abas específicas\n#df21 &lt;- read_excel(\"dados-diversos.xlsx\", \"escala\")\n#df21 &lt;- read_excel(\"dados-diversos.xlsx\", 2)"
  },
  {
    "objectID": "aula_02b.html#leitura-e-importação-de-dados-de-arquivos-csv",
    "href": "aula_02b.html#leitura-e-importação-de-dados-de-arquivos-csv",
    "title": "Importando e Manipulando dados",
    "section": "",
    "text": "Outra opção, para arquivos CSV, é a utilização do pacote tidyverse, uma coleção de pacotes R para ciência de dados, incluindo readr para leitura de arquivos CSV. O tidyverse simplifica e uniformiza várias operações de manipulação de dados.\nNeste caso utilizamos a função read_csv``(\"nome_do_arquivo.xlsx\"), lembrando que, caso o arquivo esteja em outra pasta é necessário colocar o caminho do arquivo antes do nome.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndf3 &lt;- read_csv(\"dados-diversos.csv\")\n\nRows: 60 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Irrigation\ndbl (3): rep, day, severity\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "aula_02b.html#leitura-e-importação-de-dados-de-arquivos-do-drive-utilizando-google-sheets",
    "href": "aula_02b.html#leitura-e-importação-de-dados-de-arquivos-do-drive-utilizando-google-sheets",
    "title": "Importando e Manipulando dados",
    "section": "",
    "text": "Atualmente a utilização de drives em nuvem para salvar bancos de dados está amplamente difundida Isso é devido a facilidade de acesso aos dados, que pode ser feita de qualquer dispositivo, desde que se tenha acesso a internet.\nPara utilizar um banco de dados diretamente do Google Drive, por exemplo, pode-se utilizar os pacotes gsheet e googlesheets4. O pacote gsheet permite a leitura rápida de Google Sheets usando URLs, enquanto o googlesheets4 oferece funcionalidade mais abrangente para leitura e escrita em Google Sheets.\nNo caso do pacote gsheet, a função utilizada para abrir e importar dados de arquivos no Google Drive é o gsheet2tbl(``\"link_do_arquivo\").\n\nlibrary(gsheet)\ndf4 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137\")\n\ndf41 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?usp=drive_link&ouid=104144100918915406194&rtpof=true&sd=true\", sheetid = \"3\")\n\nPara o pacote googlesheets4, o nome da função é read_sheet``(\"link_do_arquivo\"). Ele permite não somente baixar, mas ele permite também escrever nos arquivos.\nlibrary(googlesheets4) df5 &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\")"
  },
  {
    "objectID": "aula_02b.html#visualização-de-dados",
    "href": "aula_02b.html#visualização-de-dados",
    "title": "Importando e Manipulando dados",
    "section": "",
    "text": "Para criar gráficos para análise exploratória das variáveis, utilizaremos o ggplot2, um dos pacotes mais populares do R para visualização de dados. A função geom_point mostra os pontos de uma variável, mas pode ocorrer destes pontos estarem sobrepostos, assim pode-se utilizar a função geom_jitter para desagregar os pontos.\nPodemos adicionar camadas com o operador +, como geom_boxplot. A ordem das camadas determina como elas serão exibidas: a primeira camada chamada fica na parte inferior e as subsequentes são empilhadas acima.\nPara evitar duplicação de outliers, utilize outlier.colour = NA.\nTemas específicos também podem ser aplicados, como theme_bw() para um visual preto e branco utilizado em artigos cientificos, ou theme_classic.\n\nlibrary(ggplot2)\ng1 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_point(color = \"red\", shape = 2, size = 3)\ng1 + theme_classic()+\n  labs(x = \"Tratamento\", #Label do eixo x\n       y = \"Comprimento\", #Label do eixo y\n       title = \"Meu primeiro ggplot\", #Adiciona título ao gráfico\n       caption = \"Fonte: Dados diversos\") #Adiciona fonte ao gráfico\n\n\n\n\n\n\n\ng2 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_boxplot(outlier.colour = NA,\n               fill = \"green\")+\n  geom_jitter(width = 0.05,\n              color = \"blue\",\n              shape = 3,\n              size = 2)\ng2 + theme_bw() +\n  #ylim(0,20) #Outra opção para a função abaixo\n  scale_y_continuous(limits = c(0,20),\n                     n.breaks = 5) #n.breaks é o número de quebras, se colocar breaks apenas, fica só a linha correspondente aquele número.\n\n\n\n\n\n\n\n\nApós a criação do gráfico, através do pacote ggplot2, podemos salvar os gráficos utilizando a função ggsave. A função ggsave é usada para salvar gráficos criados com ggplot2 em diferentes formatos de arquivo, como PNG, PDF, JPEG, entre outros. Isso é útil para documentar visualizações, compartilhar resultados ou incluir gráficos em relatórios e apresentações.\n\nggsave(\"plot1.png\", bg = \"white\") #O parâmetro \"bg\" é a cor de fundo ou \"background\"\n\nSaving 7 x 5 in image\n\n\nEntendendo esses passos, você será capaz de importar dados de diversas fontes, realizar manipulações e criar visualizações ricas utilizando R e seus pacotes associados. Cada pacote desempenha um papel crucial na simplificação e eficiência das suas tarefas de análise de dados."
  },
  {
    "objectID": "aula_01b.html",
    "href": "aula_01b.html",
    "title": "R Markdown e Quarto Document",
    "section": "",
    "text": "Ferramentas de autoria são softwares ou plataformas que permitem aos usuários criar, editar e publicar conteúdo. Essas ferramentas são projetadas para facilitar a produção de documentos, apresentações, relatórios, livros e outros tipos de conteúdo técnico ou educacional. Elas geralmente oferecem recursos que combinam texto, multimídia e, em alguns casos, código de programação para gerar documentos dinâmicos e interativos.\n\n\nR Markdown é uma ferramenta que permite combinar texto, código R e os resultados do código (como gráficos e tabelas) em um único documento. É usada para criar relatórios dinâmicos, apresentações e documentos que podem ser exportados para formatos como HTML, PDF e Word. É especialmente útil para criar análises reprodutíveis, pois integra o código diretamente no documento.\n\n\n\nQuarto é uma plataforma que expande as capacidades do R Markdown, suportando as linguagens R, Python, Julia e Observable JavaScript. Ele permite a criação de documentos técnicos, relatórios, blogs, livros e apresentações. Quarto oferece maior flexibilidade, suporte a múltiplas linguagens e integração com ferramentas modernas como GitHub Actions.\n\n\n\n\nR Markdown: Principalmente para R, focado em relatórios reprodutíveis e apresentações.\nQuarto: Suporta várias linguagens, oferece mais personalização e é ideal para uma ampla gama de documentos técnicos.\n\nOBS.: Nas aulas, foi optado pelo Quarto para documentar as aulas devido a sua ampla gama de ferrementas e capacidade de integração com outras ferramentas."
  },
  {
    "objectID": "aula_01b.html#r-markdown",
    "href": "aula_01b.html#r-markdown",
    "title": "R Markdown e Quarto Document",
    "section": "",
    "text": "R Markdown é uma ferramenta que permite combinar texto, código R e os resultados do código (como gráficos e tabelas) em um único documento. É usada para criar relatórios dinâmicos, apresentações e documentos que podem ser exportados para formatos como HTML, PDF e Word. É especialmente útil para criar análises reprodutíveis, pois integra o código diretamente no documento."
  },
  {
    "objectID": "aula_01b.html#quarto-document",
    "href": "aula_01b.html#quarto-document",
    "title": "R Markdown e Quarto Document",
    "section": "",
    "text": "Quarto é uma plataforma que expande as capacidades do R Markdown, suportando as linguagens R, Python, Julia e Observable JavaScript. Ele permite a criação de documentos técnicos, relatórios, blogs, livros e apresentações. Quarto oferece maior flexibilidade, suporte a múltiplas linguagens e integração com ferramentas modernas como GitHub Actions."
  },
  {
    "objectID": "aula_01b.html#diferenças",
    "href": "aula_01b.html#diferenças",
    "title": "R Markdown e Quarto Document",
    "section": "",
    "text": "R Markdown: Principalmente para R, focado em relatórios reprodutíveis e apresentações.\nQuarto: Suporta várias linguagens, oferece mais personalização e é ideal para uma ampla gama de documentos técnicos.\n\nOBS.: Nas aulas, foi optado pelo Quarto para documentar as aulas devido a sua ampla gama de ferrementas e capacidade de integração com outras ferramentas."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "aula_01a.html",
    "href": "aula_01a.html",
    "title": "Instalação",
    "section": "",
    "text": "A linguagem de programação R é um ambiente de software livre voltado para computação estatística e gráficos, amplamente utilizada por estatísticos, cientistas de dados e analistas. Desenvolvida inicialmente na Universidade de Auckland, R é conhecida por suas capacidades avançadas de análise de dados, visualização gráfica e extensa biblioteca de pacotes disponíveis no CRAN. Sua flexibilidade permite a realização de tarefas que vão desde a manipulação de dados simples até modelagem estatística complexa. Gratuito e de código aberto, R conta com uma comunidade ativa que contribui para seu contínuo desenvolvimento e aplicação em diversas áreas, incluindo pesquisa acadêmica, finanças e bioinformática.\nO RStudio é um ambiente de desenvolvimento integrado (IDE) para a linguagem R, projetado para facilitar a análise de dados e o desenvolvimento de código, apesar de não ser obrigatório para o funcionamento do software R sua instalação e utilização é amplamente recomendada. Ele oferece um editor de código avançado, um console interativo, ferramentas de visualização de dados, gerenciamento de pacotes e suporte a RMarkdown, além de integração com sistemas de controle de versão como Git e SVN. Com uma interface intuitiva e recursos que aumentam a produtividade, RStudio é amplamente utilizado tanto por iniciantes quanto por especialistas em ciência de dados.\n\n\nInstalar o R é um processo simples e direto. Siga os passos abaixo para instalar o R no seu sistema:\n\n\n\nAcesse o site oficial do R:\n\nAbra seu navegador e vá para CRAN (The Comprehensive R Archive Network).\n\nEscolha seu sistema operacional:\n\nWindows: Clique em “Download R for Windows”.\nmacOS: Clique em “Download R for (Mac) OS X”.\nLinux: Clique em “Download R for Linux”.\n\nBaixe o instalador:\nExecute o instalador:\nSiga as instruções do instalador:\n\nOBS.: A instalação varia de acordo com o sistema operacional do seu computador, um passo a passo mais detalhado pode ser fácilmente encontrado no site do R-Project, onde realizou o download do software.\n\n\n\n\nAbrir o R:\n\nNo Windows e macOS, procure o ícone do R no menu Iniciar ou no Launchpad, respectivamente, e clique para abrir.\nNo Linux, abra um terminal e digite R para iniciar o console do R.\n\nVerificar a versão do R:\n\nNo console do R, digite o comando version e pressione Enter. Isso exibirá informações sobre a versão do R instalada.\n\n\n\n\n\n\n\nBaixar o RStudio:\n\nAcesse o site doRStudio e baixe a versão apropriada para seu sistema operacional.\n\nInstalar o RStudio:\n\nNo Windows, execute o instalador baixado e siga as instruções.\nNo macOS, abra o pacote .dmg baixado e arraste o ícone do RStudio para a pasta Aplicativos.\nNo Linux, siga as instruções específicas para a sua distribuição no site do RStudio.\n\nAbrir o RStudio:\n\nApós a instalação, abra o RStudio a partir do menu Iniciar, Launchpad ou terminal."
  },
  {
    "objectID": "aula_01a.html#instalando-o-r-guia-rápido",
    "href": "aula_01a.html#instalando-o-r-guia-rápido",
    "title": "Instalação",
    "section": "",
    "text": "Instalar o R é um processo simples e direto. Siga os passos abaixo para instalar o R no seu sistema:\n\n\n\nAcesse o site oficial do R:\n\nAbra seu navegador e vá para CRAN (The Comprehensive R Archive Network).\n\nEscolha seu sistema operacional:\n\nWindows: Clique em “Download R for Windows”.\nmacOS: Clique em “Download R for (Mac) OS X”.\nLinux: Clique em “Download R for Linux”.\n\nBaixe o instalador:\nExecute o instalador:\nSiga as instruções do instalador:\n\nOBS.: A instalação varia de acordo com o sistema operacional do seu computador, um passo a passo mais detalhado pode ser fácilmente encontrado no site do R-Project, onde realizou o download do software.\n\n\n\n\nAbrir o R:\n\nNo Windows e macOS, procure o ícone do R no menu Iniciar ou no Launchpad, respectivamente, e clique para abrir.\nNo Linux, abra um terminal e digite R para iniciar o console do R.\n\nVerificar a versão do R:\n\nNo console do R, digite o comando version e pressione Enter. Isso exibirá informações sobre a versão do R instalada."
  },
  {
    "objectID": "aula_01a.html#instalando-o-rstudio",
    "href": "aula_01a.html#instalando-o-rstudio",
    "title": "Instalação",
    "section": "",
    "text": "Baixar o RStudio:\n\nAcesse o site doRStudio e baixe a versão apropriada para seu sistema operacional.\n\nInstalar o RStudio:\n\nNo Windows, execute o instalador baixado e siga as instruções.\nNo macOS, abra o pacote .dmg baixado e arraste o ícone do RStudio para a pasta Aplicativos.\nNo Linux, siga as instruções específicas para a sua distribuição no site do RStudio.\n\nAbrir o RStudio:\n\nApós a instalação, abra o RStudio a partir do menu Iniciar, Launchpad ou terminal."
  },
  {
    "objectID": "aula_02a.html",
    "href": "aula_02a.html",
    "title": "Pacotes no R",
    "section": "",
    "text": "Pacotes são coleções de funções, dados e documentação que expandem as capacidades básicas do R. O tidyverse, que usaremos como exemplo, é um conjunto de pacotes R projetados para a ciência de dados, incluindo ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr e forcats.\n\n\nPara instalar pacotes como tidyverse, você pode usar a função install.packages():\ninstall.packages(\"tidyverse\")\nCaso esteje utilizando o RStudio, pode acessar o menu de instalação de pacotes e instalar seguindo os seguintes passos:\n\nNo menu superior do RStudio, clique em Tools.\nSelecione Install Packages... no menu suspenso.\nNa janela que se abre, digite o nome do pacote, no nosso caso o tidyverse, no campo de texto.\nCertifique-se de que a opção “Install dependencies” está marcada, para que todas as dependências sejam instaladas também.\nClique no botão Install.\n\n\n\n\nO carregamento de pacotes pode ser feito pelo menu ou então com um comando no console. Após a instalação, você precisa carregar o pacote para utilizá-lo em sua sessão de R. Isso é feito com a função library():\nlibrary(tidyverse)\nUma vez carregado, você pode utilizar as funções e dados disponíveis no pacote carregado.\n\n\n\nPara obter ajuda sobre um pacote ou uma função específica, você pode usar a função help() ou ?. Por exemplo, para obter ajuda sobre o pacote tidyverse:\nhelp(package = \"tidyverse\")\nOu para obter ajuda sobre uma função específica dentro do dplyr, como mutate:\n?mutate\nVocê também pode usar a função help.search() para buscar tópicos de ajuda relacionados a um termo específico:\nhelp.search(\"mutate\")\nAlém disso, a função vignette() pode ser usada para acessar tutoriais e exemplos incluídos no pacote. Para listar todas as vinhetas disponíveis:\nvignette(package = \"tidyverse\")\nE para abrir uma vinheta específica:\nvignette(\"tidy-data\")"
  },
  {
    "objectID": "aula_02a.html#como-instalar",
    "href": "aula_02a.html#como-instalar",
    "title": "Pacotes no R",
    "section": "",
    "text": "Para instalar pacotes como tidyverse, você pode usar a função install.packages():\ninstall.packages(\"tidyverse\")\nCaso esteje utilizando o RStudio, pode acessar o menu de instalação de pacotes e instalar seguindo os seguintes passos:\n\nNo menu superior do RStudio, clique em Tools.\nSelecione Install Packages... no menu suspenso.\nNa janela que se abre, digite o nome do pacote, no nosso caso o tidyverse, no campo de texto.\nCertifique-se de que a opção “Install dependencies” está marcada, para que todas as dependências sejam instaladas também.\nClique no botão Install."
  },
  {
    "objectID": "aula_02a.html#como-carregar-os-pacotes",
    "href": "aula_02a.html#como-carregar-os-pacotes",
    "title": "Pacotes no R",
    "section": "",
    "text": "O carregamento de pacotes pode ser feito pelo menu ou então com um comando no console. Após a instalação, você precisa carregar o pacote para utilizá-lo em sua sessão de R. Isso é feito com a função library():\nlibrary(tidyverse)\nUma vez carregado, você pode utilizar as funções e dados disponíveis no pacote carregado."
  },
  {
    "objectID": "aula_02a.html#como-pedir-ou-ver-ajuda-sobre-o-pacote",
    "href": "aula_02a.html#como-pedir-ou-ver-ajuda-sobre-o-pacote",
    "title": "Pacotes no R",
    "section": "",
    "text": "Para obter ajuda sobre um pacote ou uma função específica, você pode usar a função help() ou ?. Por exemplo, para obter ajuda sobre o pacote tidyverse:\nhelp(package = \"tidyverse\")\nOu para obter ajuda sobre uma função específica dentro do dplyr, como mutate:\n?mutate\nVocê também pode usar a função help.search() para buscar tópicos de ajuda relacionados a um termo específico:\nhelp.search(\"mutate\")\nAlém disso, a função vignette() pode ser usada para acessar tutoriais e exemplos incluídos no pacote. Para listar todas as vinhetas disponíveis:\nvignette(package = \"tidyverse\")\nE para abrir uma vinheta específica:\nvignette(\"tidy-data\")"
  },
  {
    "objectID": "aula_03.html",
    "href": "aula_03.html",
    "title": "Análise exploratória: Visualização de dados",
    "section": "",
    "text": "A visualização de dados é um componente essencial na análise de dados, permitindo que você explore, entenda e comunique padrões, tendências e insights de forma eficaz. Utilizando gráficos e tabelas, você pode transformar dados brutos em informações visuais compreensíveis, facilitando a interpretação e tomada de decisões. No R, pacotes como ggplot2, tidyverse e patchwork oferecem ferramentas poderosas para criar visualizações sofisticadas e personalizadas.\n\n\nPara abrir uma planilha em formato .CSV, utilizamos o pacote tidyverse. Este pacote inclui o readr, que oferece a função read_csv para ler arquivos CSV de maneira eficiente.\nCaso hajam dúvidas sobre como abrir e importar arquivos ou os arquivos estejam em outros formatos, sugiro ler a aula “Importando Datasets” na aba “Básico”.\n\n\nUma dica importante é colocar dentro do primeiro chunk, #| warning: false e #| message: false para não sejam exibidos avisos e mensagens ao renderizar o documento. Se preferir, você pode aplicar essa configuração a todos os chunks colocando no cabeçalho do documento.\n\n#Carregando pacote\nlibrary(tidyverse)\n#Importando arquivo CSV do Git Hub\ncr &lt;- read_csv(\"https://raw.githubusercontent.com/emdelponte/paper-coffee-rust-Ethiopia/master/data/survey_clean.csv\")\n\n\n\n\nExplorar e entender os dados é fundamental para uma boa análise destes dados. A função head apresenta um sumário dos dados, com as 6 primeiras linhas e as colunas existentes, com o nome da variável e o tipo da variável. Assim essa função permite um entendimento do que são os seus dados, variáveis e tipo delas.\n\nhead(cr)\n\n# A tibble: 6 × 13\n   farm region zone       district      lon   lat altitude cultivar shade    \n  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    \n1     1 SNNPR  Bench Maji Debub Bench  35.4  6.90     1100 Local    Sun      \n2     2 SNNPR  Bench Maji Debub Bench  35.4  6.90     1342 Mixture  Mid shade\n3     3 SNNPR  Bench Maji Debub Bench  35.4  6.90     1434 Mixture  Mid shade\n4     4 SNNPR  Bench Maji Debub Bench  35.4  6.90     1100 Local    Sun      \n5     5 SNNPR  Bench Maji Debub Bench  35.4  6.90     1400 Local    Sun      \n6     6 SNNPR  Bench Maji Debub Bench  35.4  6.90     1342 Mixture  Mid shade\n# ℹ 4 more variables: cropping_system &lt;chr&gt;, farm_management &lt;chr&gt;, inc &lt;dbl&gt;,\n#   sev2 &lt;dbl&gt;\n\n\nOutra opção para visualizar o conjunto de dados é a função glimpse que mostra detalhes da tabela, como nome da variável, tipo e uma pequana amostra dos dados desta váriaveis.\n\nglimpse(cr)\n\nRows: 405\nColumns: 13\n$ farm            &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ region          &lt;chr&gt; \"SNNPR\", \"SNNPR\", \"SNNPR\", \"SNNPR\", \"SNNPR\", \"SNNPR\", …\n$ zone            &lt;chr&gt; \"Bench Maji\", \"Bench Maji\", \"Bench Maji\", \"Bench Maji\"…\n$ district        &lt;chr&gt; \"Debub Bench\", \"Debub Bench\", \"Debub Bench\", \"Debub Be…\n$ lon             &lt;dbl&gt; 35.44250, 35.44250, 35.42861, 35.42861, 35.42861, 35.3…\n$ lat             &lt;dbl&gt; 6.904722, 6.904722, 6.904444, 6.904444, 6.904444, 6.90…\n$ altitude        &lt;dbl&gt; 1100, 1342, 1434, 1100, 1400, 1342, 1432, 1100, 1400, …\n$ cultivar        &lt;chr&gt; \"Local\", \"Mixture\", \"Mixture\", \"Local\", \"Local\", \"Mixt…\n$ shade           &lt;chr&gt; \"Sun\", \"Mid shade\", \"Mid shade\", \"Sun\", \"Sun\", \"Mid sh…\n$ cropping_system &lt;chr&gt; \"Plantation\", \"Plantation\", \"Plantation\", \"Plantation\"…\n$ farm_management &lt;chr&gt; \"Unmanaged\", \"Minimal\", \"Minimal\", \"Unmanaged\", \"Unman…\n$ inc             &lt;dbl&gt; 86.70805, 51.34354, 43.20000, 76.70805, 47.15808, 51.3…\n$ sev2            &lt;dbl&gt; 55.57986, 17.90349, 8.25120, 46.10154, 12.25167, 19.91…\n\n\n\n\n\nOs histogramas ajudam a observar a distribuição dos dados, a função para isso é geom_histogram() do pacote ggplot2. Podemos plotar um histograma para cada região utilizando o facet_wrap.\n\nlibrary(ggplot2)\n# Histogramas de incidência por região\ncr |&gt;\n  ggplot(aes(x = inc))+\n  geom_histogram()+ #Histograma\n  facet_wrap(~region) #Separa por região.\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nAlém disso, o comando summary fornece um sumário estatístico das variáveis. E assim como foi plotado um histograma para cada região, podemos pedir um sumário para cada região ou até por cultivar agrupando utilizando a função group_by().\nDentro da função summarize, podemos utilizar as funções para obter a média, mediana e desvio padrão através das funções mean(), median() e sd(), respectivamente.\n\n# Sumário dos dados de incidência\nsummary(cr$inc)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.50   19.43   32.50   34.89   48.20   86.71 \n\n\n\n# Estatísticas de incidência por região\ncr |&gt;\n  group_by(region) |&gt;\n  summarize(inc_mean = mean(inc),\n            inc_med = median(inc),\n            sd_mean = sd(inc))\n\n# A tibble: 2 × 4\n  region inc_mean inc_med sd_mean\n  &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Oromia     37.0    39.5    14.6\n2 SNNPR      33.4    29.6    18.9\n\n\n\n# Estatísticas de incidência por cultivar\ncr |&gt;\n  group_by(cultivar) |&gt;\n  summarize(inc_mean = mean(inc),\n            inc_med = median(inc),\n            sd_mean = sd(inc))\n\n# A tibble: 3 × 4\n  cultivar inc_mean inc_med sd_mean\n  &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Improved     16.4    15.2    5.66\n2 Local        53.4    50.9   14.3 \n3 Mixture      31.9    31.6   11.2 \n\n\n\n\n\nA média (mean) é a soma de todos os valores dividida pelo número total de observações. Ela fornece uma ideia do valor central dos dados.\nA mediana (Median) é o valor central de um conjunto de dados ordenado. Se o número de observações for par, é a média dos dois valores centrais. Ela divide os dados em duas metades iguais.\nO desvio padrão (Standard Deviation) mede a dispersão dos valores em relação à média. Um desvio padrão alto indica valores espalhados, enquanto um desvio padrão baixo indica valores próximos à média.\n\n\n\n\n\nPara observar a relação entre duas variáveis, podemos utilizar gráficos de dispersão e para observar essa relação pode ser utilizado a função geom_point().\n\ncr |&gt;\n  ggplot(aes(inc, sev2))+\n  geom_point()\n\n\n\n\n\n\n\n\nPodemos obervar melhor a simetria das variáveis, se a mediana e média dos dados forem mais próximas uma da outra, a curva é simétrica. Se os dados forem não simétricos, podemos observar uma assimetria com cauda para a direita ou a esquerda.\n\nlibrary(ggplot2)\ncr |&gt;\n  ggplot(aes(x = sev2))+\n  geom_histogram()+\n  facet_wrap(~region) #Separa por região.\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nsummary(cr$sev2)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2248  2.6892  5.9490  9.0945 12.1593 55.5799 \n\ncr |&gt;\n  group_by(region) |&gt;\n  summarize(sev_mean = mean(sev2),\n            sev_med = median(sev2),\n            sd_mean = sd(sev2))\n\n# A tibble: 2 × 4\n  region sev_mean sev_med sd_mean\n  &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Oromia     8.06    6.23    6.82\n2 SNNPR      9.81    4.88   10.5 \n\n\nAssim, relembrando, a simetria das variáveis pode ser observada através de histogramas e variáveis simétricas terão médias e medianas próximas, enquanto variáveis assimétricas não apresentam médias e medianas próximas e podem mostrar caudas ao ser plotado o histograma como o exemplo acima.\nPorém, se formos olhar por cultivar, os dados ficam mais simétrico, como mostrado abaixo:\n\nlibrary(ggplot2)\ncr |&gt;\n  ggplot(aes(x = sev2))+\n  geom_histogram()+\n  facet_wrap(~cultivar) #Separa por região.\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nsummary(cr$sev2)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2248  2.6892  5.9490  9.0945 12.1593 55.5799 \n\ncr |&gt;\n  group_by(cultivar) |&gt;\n  summarize(sev_mean = mean(sev2),\n            sev_med = median(sev2),\n            sd_mean = sd(sev2))\n\n# A tibble: 3 × 4\n  cultivar sev_mean sev_med sd_mean\n  &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Improved     2.16    1.64    1.82\n2 Local       18.7    17.2    11.1 \n3 Mixture      6.47    5.43    4.35\n\n\n\n\n\nOs gráficos podem ser personalizados de uma infinidade de formas, por exemplo, podemos modificar as cores por região. Lembrando de colocar fill na função ggplot, se for colocado depois ele irá alterar os gráficos. De mesma forma quando usamos um tema, como o theme_minimal usado no exemplo, tem que ver após o scale_fill_manual, pois irá sobrescever o tema anterior.\n\nlibrary(ggthemes)\ncr |&gt;\n  ggplot(aes(x = sev2, fill = region))+ #Aqui foi adicionado o fill\n  geom_histogram(color = \"white\")+ #Color aqui é para aborda das barras do histograma.\n  facet_wrap(region ~ cultivar, ncol = 6)+ #ncol coloca o número de colunas por plot\n  #scale_fill_colorblind() #Aqui altera a plheta de cores\n  scale_fill_manual(values = c(\"red\", \"blue\"))+ #escolha manual\n  theme_minimal(base_size = 14)+ #vem depois, se não sobrescreve o scale_fill_manual, aqui também altera a fonte com base_size)\n  theme(legend.position = \"bottom\")+\n  labs(y = \"Frequency\",\n       x = \"Severity (%)\",\n       fill = \"Region\") #Alterou o nome, que estava como o da variável\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nggsave(\"cr1.png\", bg =\"white\")\n\nSaving 7 x 5 in image\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nPara criar subconjuntos de dados, podemos selecionar as colunas com a função select() e podemos atribuir este subconjunto a um objeto, como no exemplo o objeto cr2. No exemplo foram selecionados as colunas, ou variáveis, fazenda (farm), região (region), cultivar (cultivar) e severidade (sev2).\n\ncr2 &lt;- cr |&gt;\n  select(farm, region, cultivar, sev2) #select é pra colunas\n\ncr2\n\n# A tibble: 405 × 4\n    farm region cultivar  sev2\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n 1     1 SNNPR  Local    55.6 \n 2     2 SNNPR  Mixture  17.9 \n 3     3 SNNPR  Mixture   8.25\n 4     4 SNNPR  Local    46.1 \n 5     5 SNNPR  Local    12.3 \n 6     6 SNNPR  Mixture  19.9 \n 7     7 SNNPR  Mixture  11.9 \n 8     8 SNNPR  Local    55.6 \n 9     9 SNNPR  Local    11.6 \n10    10 SNNPR  Mixture  11.4 \n# ℹ 395 more rows\n\n\nPodemos também, filtrar os dados usando o filter() do pacote dplyr em conjunto com a função select() para escolher colunas e filtrar as linhas.\n\n#Filtra Oromia\ncr_oromia &lt;- cr |&gt;\n  select(farm, region, cultivar, sev2) |&gt; #select é pra colunas\n  filter(region == \"Oromia\")\ncr_oromia\n\n# A tibble: 165 × 4\n    farm region cultivar  sev2\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n 1   286 Oromia Mixture   7.63\n 2   287 Oromia Mixture   9.39\n 3   288 Oromia Mixture   1.30\n 4   289 Oromia Mixture   9.79\n 5   290 Oromia Local    18.5 \n 6   291 Oromia Mixture  13.2 \n 7   292 Oromia Mixture   5.60\n 8   293 Oromia Mixture   1.06\n 9   294 Oromia Local    17.6 \n10   295 Oromia Mixture  15.4 \n# ℹ 155 more rows\n\n#Filtra SNNPR\ncr_pr &lt;- cr |&gt;\n  select(farm, region, cultivar, sev2) |&gt;#select é pra colunas\n  filter(region == \"SNNPR\")\ncr_pr\n\n# A tibble: 240 × 4\n    farm region cultivar  sev2\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n 1     1 SNNPR  Local    55.6 \n 2     2 SNNPR  Mixture  17.9 \n 3     3 SNNPR  Mixture   8.25\n 4     4 SNNPR  Local    46.1 \n 5     5 SNNPR  Local    12.3 \n 6     6 SNNPR  Mixture  19.9 \n 7     7 SNNPR  Mixture  11.9 \n 8     8 SNNPR  Local    55.6 \n 9     9 SNNPR  Local    11.6 \n10    10 SNNPR  Mixture  11.4 \n# ℹ 230 more rows\n\n\n\n\n\nAinda podemos gerar gráficos ggplot2 para cada subconjunto para uma melhor visualização dos dados. No caso utilizamos o boxplot através da função geom_boxplot(), também do pacote ggplot2.\nO box plot é uma representação gráfica que mostra a distribuição de um conjunto de dados de maneira resumida, destacando a mediana, os quartis e os outliers. Os componentes de um boxplot são:\n\nCaixa:\n\nQuartil Inferior (Q1): Marca os 25% mais baixos dos dados.\nMediana (Q2): O valor central dos dados (50%).\nQuartil Superior (Q3): Marca os 75% mais baixos dos dados.\n\nWhiskers:\n\nLinhas que se estendem dos quartis até o valor mínimo e máximo dentro de 1.5 vezes o intervalo interquartil (IQR).\n\nOutliers:\n\nPontos fora do alcance dos whiskers, indicando valores atípicos.\n\n\n\ncr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2))+\n  geom_boxplot()+\n  labs(title = \"Oromia\",\n       X = \"Cultivar\",\n       y = \"Severity (%)\")\n\n\n\n\n\n\n\n\n\ncr_pr |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2))+\n  geom_boxplot()+\n  labs(title = \"SNNPR\",\n       X = \"Cultivar\",\n       y = \"Severity (%)\")\n\n\n\n\n\n\n\n\nO box plot é útil para identificar a mediana, a dispersão, a assimetria e os outliers em um conjunto de dados, facilitando a comparação entre diferentes grupos ou categorias.\n\n\n\nGráficos exibidos lado a lado podem auxiliar na percepção de diferença entre dois grupos quando queremos apresenta-las ao leitor de um artigo, por exemplo. Assim, para plotar dois gráficos lado a lado iremos utilizar a biblioteca patchwork, sem usar o face_wrap.\n\np1 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")#+ #lembrar de tirar o comentário do +\n  #coord_flip() #rotaciona as coordenadas\n\np2 &lt;- cr_pr |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")#+ #lembrar de tirar o comentário do +\n  coord_flip() #rotaciona as coordenadas\n\n&lt;ggproto object: Class CoordFlip, CoordCartesian, Coord, gg&gt;\n    aspect: function\n    backtransform_range: function\n    clip: on\n    default: FALSE\n    distance: function\n    expand: TRUE\n    is_free: function\n    is_linear: function\n    labels: function\n    limits: list\n    modify_scales: function\n    range: function\n    render_axis_h: function\n    render_axis_v: function\n    render_bg: function\n    render_fg: function\n    setup_data: function\n    setup_layout: function\n    setup_panel_guides: function\n    setup_panel_params: function\n    setup_params: function\n    train_panel_guides: function\n    transform: function\n    super:  &lt;ggproto object: Class CoordFlip, CoordCartesian, Coord, gg&gt;\n\nlibrary(patchwork)\n\n(p1 + p2) + #Pode ser + ou |, se colocar / coloca um sobre o outro. Ele funciona como equação, pode ser feito combinação dos gráficos como p1/(p2+p1)\nplot_layout(guides = \"collect\") + #Deixa somente uma legenda\nplot_annotation(tag_levels = \"A\") #Diferencia maiúsculas e minúsculas\n\n\n\n\n\n\n\nggsave(\"patch.png\")\n\nSaving 7 x 5 in image\n\n\nPodemos usar o artifício da função coord_flip(), para rotacionar as coordenadas de uma imagem ou das duas, caso fique visualmente mais adequado para a explicação dos dados.\n\np1 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  theme_few() +\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")+\n  coord_flip() #rotaciona as coordenadas\n\np2 &lt;- cr_pr |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  theme_few() +\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")+\n  coord_flip() #rotaciona as coordenadas\n\n#Não consegui instalar o patchwork\nlibrary(patchwork)\n\n(p1 / p2) + #pode ser + ou |, se colocar / coloca um sobre o outro. Ele funciona como equação, pode ser feito combinação dos gráficos como p1/(p2+p1)\nplot_layout(guides = \"collect\",\n            axes = \"collect\")+ #Deixa somente uma legenda\nplot_annotation(title = \"Coffe rust is Ethiopia\",\n                caption = \"source: Serafini (2024)\",\n                tag_levels = \"A\") #diferencia maiúsculas e minúsculas\n\n\n\n\n\n\n\nggsave(\"patch2.png\", width = 5, height = 4)\n\nOutra opção de combinações que o pacote permite é a sobreposição de gráficos através da função inset_element(), onde é inserido o gráfico que se deseja plotar e as dimensões/posições deste na imagem. Este é um excelente artifício para exibir informações gráficas complementares em uma mesma imagem.\n\np1 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  theme_few() +\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")+\n  coord_flip() #rotaciona as coordenadas\n\np3 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = sev2))+\n  geom_histogram() +\n  labs(y = \"Freq.\",\n       x = \"Severity (%)\")\n\np1 + inset_element(p3, left = 0.6,\n                    bottom = 0.6,\n                    right = 1,\n                    top = 1) +\n  plot_annotation(title = \"Coffe rust is Ethiopia\",\n                caption = \"source: Serafini (2024)\",\n                tag_levels = \"A\") #diferencia maiúsculas e minúsculas\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nggsave(\"patch3.png\", width = 5, height = 4)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nO patchwork tem várias possíbilidades interessantes, vale a pena olhar a ajuda (help) deste pacote!"
  },
  {
    "objectID": "aula_03.html#abrindo-e-importando-arquivo-csv",
    "href": "aula_03.html#abrindo-e-importando-arquivo-csv",
    "title": "Análise exploratória: Visualização de dados",
    "section": "",
    "text": "Para abrir uma planilha em formato .CSV, utilizamos o pacote tidyverse. Este pacote inclui o readr, que oferece a função read_csv para ler arquivos CSV de maneira eficiente.\nCaso hajam dúvidas sobre como abrir e importar arquivos ou os arquivos estejam em outros formatos, sugiro ler a aula “Importando Datasets” na aba “Básico”.\n\n\nUma dica importante é colocar dentro do primeiro chunk, #| warning: false e #| message: false para não sejam exibidos avisos e mensagens ao renderizar o documento. Se preferir, você pode aplicar essa configuração a todos os chunks colocando no cabeçalho do documento.\n\n#Carregando pacote\nlibrary(tidyverse)\n#Importando arquivo CSV do Git Hub\ncr &lt;- read_csv(\"https://raw.githubusercontent.com/emdelponte/paper-coffee-rust-Ethiopia/master/data/survey_clean.csv\")\n\n\n\n\nExplorar e entender os dados é fundamental para uma boa análise destes dados. A função head apresenta um sumário dos dados, com as 6 primeiras linhas e as colunas existentes, com o nome da variável e o tipo da variável. Assim essa função permite um entendimento do que são os seus dados, variáveis e tipo delas.\n\nhead(cr)\n\n# A tibble: 6 × 13\n   farm region zone       district      lon   lat altitude cultivar shade    \n  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    \n1     1 SNNPR  Bench Maji Debub Bench  35.4  6.90     1100 Local    Sun      \n2     2 SNNPR  Bench Maji Debub Bench  35.4  6.90     1342 Mixture  Mid shade\n3     3 SNNPR  Bench Maji Debub Bench  35.4  6.90     1434 Mixture  Mid shade\n4     4 SNNPR  Bench Maji Debub Bench  35.4  6.90     1100 Local    Sun      \n5     5 SNNPR  Bench Maji Debub Bench  35.4  6.90     1400 Local    Sun      \n6     6 SNNPR  Bench Maji Debub Bench  35.4  6.90     1342 Mixture  Mid shade\n# ℹ 4 more variables: cropping_system &lt;chr&gt;, farm_management &lt;chr&gt;, inc &lt;dbl&gt;,\n#   sev2 &lt;dbl&gt;\n\n\nOutra opção para visualizar o conjunto de dados é a função glimpse que mostra detalhes da tabela, como nome da variável, tipo e uma pequana amostra dos dados desta váriaveis.\n\nglimpse(cr)\n\nRows: 405\nColumns: 13\n$ farm            &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ region          &lt;chr&gt; \"SNNPR\", \"SNNPR\", \"SNNPR\", \"SNNPR\", \"SNNPR\", \"SNNPR\", …\n$ zone            &lt;chr&gt; \"Bench Maji\", \"Bench Maji\", \"Bench Maji\", \"Bench Maji\"…\n$ district        &lt;chr&gt; \"Debub Bench\", \"Debub Bench\", \"Debub Bench\", \"Debub Be…\n$ lon             &lt;dbl&gt; 35.44250, 35.44250, 35.42861, 35.42861, 35.42861, 35.3…\n$ lat             &lt;dbl&gt; 6.904722, 6.904722, 6.904444, 6.904444, 6.904444, 6.90…\n$ altitude        &lt;dbl&gt; 1100, 1342, 1434, 1100, 1400, 1342, 1432, 1100, 1400, …\n$ cultivar        &lt;chr&gt; \"Local\", \"Mixture\", \"Mixture\", \"Local\", \"Local\", \"Mixt…\n$ shade           &lt;chr&gt; \"Sun\", \"Mid shade\", \"Mid shade\", \"Sun\", \"Sun\", \"Mid sh…\n$ cropping_system &lt;chr&gt; \"Plantation\", \"Plantation\", \"Plantation\", \"Plantation\"…\n$ farm_management &lt;chr&gt; \"Unmanaged\", \"Minimal\", \"Minimal\", \"Unmanaged\", \"Unman…\n$ inc             &lt;dbl&gt; 86.70805, 51.34354, 43.20000, 76.70805, 47.15808, 51.3…\n$ sev2            &lt;dbl&gt; 55.57986, 17.90349, 8.25120, 46.10154, 12.25167, 19.91…\n\n\n\n\n\nOs histogramas ajudam a observar a distribuição dos dados, a função para isso é geom_histogram() do pacote ggplot2. Podemos plotar um histograma para cada região utilizando o facet_wrap.\n\nlibrary(ggplot2)\n# Histogramas de incidência por região\ncr |&gt;\n  ggplot(aes(x = inc))+\n  geom_histogram()+ #Histograma\n  facet_wrap(~region) #Separa por região.\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nAlém disso, o comando summary fornece um sumário estatístico das variáveis. E assim como foi plotado um histograma para cada região, podemos pedir um sumário para cada região ou até por cultivar agrupando utilizando a função group_by().\nDentro da função summarize, podemos utilizar as funções para obter a média, mediana e desvio padrão através das funções mean(), median() e sd(), respectivamente.\n\n# Sumário dos dados de incidência\nsummary(cr$inc)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.50   19.43   32.50   34.89   48.20   86.71 \n\n\n\n# Estatísticas de incidência por região\ncr |&gt;\n  group_by(region) |&gt;\n  summarize(inc_mean = mean(inc),\n            inc_med = median(inc),\n            sd_mean = sd(inc))\n\n# A tibble: 2 × 4\n  region inc_mean inc_med sd_mean\n  &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Oromia     37.0    39.5    14.6\n2 SNNPR      33.4    29.6    18.9\n\n\n\n# Estatísticas de incidência por cultivar\ncr |&gt;\n  group_by(cultivar) |&gt;\n  summarize(inc_mean = mean(inc),\n            inc_med = median(inc),\n            sd_mean = sd(inc))\n\n# A tibble: 3 × 4\n  cultivar inc_mean inc_med sd_mean\n  &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Improved     16.4    15.2    5.66\n2 Local        53.4    50.9   14.3 \n3 Mixture      31.9    31.6   11.2 \n\n\n\n\n\nA média (mean) é a soma de todos os valores dividida pelo número total de observações. Ela fornece uma ideia do valor central dos dados.\nA mediana (Median) é o valor central de um conjunto de dados ordenado. Se o número de observações for par, é a média dos dois valores centrais. Ela divide os dados em duas metades iguais.\nO desvio padrão (Standard Deviation) mede a dispersão dos valores em relação à média. Um desvio padrão alto indica valores espalhados, enquanto um desvio padrão baixo indica valores próximos à média.\n\n\n\n\n\nPara observar a relação entre duas variáveis, podemos utilizar gráficos de dispersão e para observar essa relação pode ser utilizado a função geom_point().\n\ncr |&gt;\n  ggplot(aes(inc, sev2))+\n  geom_point()\n\n\n\n\n\n\n\n\nPodemos obervar melhor a simetria das variáveis, se a mediana e média dos dados forem mais próximas uma da outra, a curva é simétrica. Se os dados forem não simétricos, podemos observar uma assimetria com cauda para a direita ou a esquerda.\n\nlibrary(ggplot2)\ncr |&gt;\n  ggplot(aes(x = sev2))+\n  geom_histogram()+\n  facet_wrap(~region) #Separa por região.\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nsummary(cr$sev2)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2248  2.6892  5.9490  9.0945 12.1593 55.5799 \n\ncr |&gt;\n  group_by(region) |&gt;\n  summarize(sev_mean = mean(sev2),\n            sev_med = median(sev2),\n            sd_mean = sd(sev2))\n\n# A tibble: 2 × 4\n  region sev_mean sev_med sd_mean\n  &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Oromia     8.06    6.23    6.82\n2 SNNPR      9.81    4.88   10.5 \n\n\nAssim, relembrando, a simetria das variáveis pode ser observada através de histogramas e variáveis simétricas terão médias e medianas próximas, enquanto variáveis assimétricas não apresentam médias e medianas próximas e podem mostrar caudas ao ser plotado o histograma como o exemplo acima.\nPorém, se formos olhar por cultivar, os dados ficam mais simétrico, como mostrado abaixo:\n\nlibrary(ggplot2)\ncr |&gt;\n  ggplot(aes(x = sev2))+\n  geom_histogram()+\n  facet_wrap(~cultivar) #Separa por região.\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nsummary(cr$sev2)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2248  2.6892  5.9490  9.0945 12.1593 55.5799 \n\ncr |&gt;\n  group_by(cultivar) |&gt;\n  summarize(sev_mean = mean(sev2),\n            sev_med = median(sev2),\n            sd_mean = sd(sev2))\n\n# A tibble: 3 × 4\n  cultivar sev_mean sev_med sd_mean\n  &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Improved     2.16    1.64    1.82\n2 Local       18.7    17.2    11.1 \n3 Mixture      6.47    5.43    4.35\n\n\n\n\n\nOs gráficos podem ser personalizados de uma infinidade de formas, por exemplo, podemos modificar as cores por região. Lembrando de colocar fill na função ggplot, se for colocado depois ele irá alterar os gráficos. De mesma forma quando usamos um tema, como o theme_minimal usado no exemplo, tem que ver após o scale_fill_manual, pois irá sobrescever o tema anterior.\n\nlibrary(ggthemes)\ncr |&gt;\n  ggplot(aes(x = sev2, fill = region))+ #Aqui foi adicionado o fill\n  geom_histogram(color = \"white\")+ #Color aqui é para aborda das barras do histograma.\n  facet_wrap(region ~ cultivar, ncol = 6)+ #ncol coloca o número de colunas por plot\n  #scale_fill_colorblind() #Aqui altera a plheta de cores\n  scale_fill_manual(values = c(\"red\", \"blue\"))+ #escolha manual\n  theme_minimal(base_size = 14)+ #vem depois, se não sobrescreve o scale_fill_manual, aqui também altera a fonte com base_size)\n  theme(legend.position = \"bottom\")+\n  labs(y = \"Frequency\",\n       x = \"Severity (%)\",\n       fill = \"Region\") #Alterou o nome, que estava como o da variável\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nggsave(\"cr1.png\", bg =\"white\")\n\nSaving 7 x 5 in image\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`."
  },
  {
    "objectID": "aula_03.html#criação-de-subconjunto",
    "href": "aula_03.html#criação-de-subconjunto",
    "title": "Análise exploratória: Visualização de dados",
    "section": "",
    "text": "Para criar subconjuntos de dados, podemos selecionar as colunas com a função select() e podemos atribuir este subconjunto a um objeto, como no exemplo o objeto cr2. No exemplo foram selecionados as colunas, ou variáveis, fazenda (farm), região (region), cultivar (cultivar) e severidade (sev2).\n\ncr2 &lt;- cr |&gt;\n  select(farm, region, cultivar, sev2) #select é pra colunas\n\ncr2\n\n# A tibble: 405 × 4\n    farm region cultivar  sev2\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n 1     1 SNNPR  Local    55.6 \n 2     2 SNNPR  Mixture  17.9 \n 3     3 SNNPR  Mixture   8.25\n 4     4 SNNPR  Local    46.1 \n 5     5 SNNPR  Local    12.3 \n 6     6 SNNPR  Mixture  19.9 \n 7     7 SNNPR  Mixture  11.9 \n 8     8 SNNPR  Local    55.6 \n 9     9 SNNPR  Local    11.6 \n10    10 SNNPR  Mixture  11.4 \n# ℹ 395 more rows\n\n\nPodemos também, filtrar os dados usando o filter() do pacote dplyr em conjunto com a função select() para escolher colunas e filtrar as linhas.\n\n#Filtra Oromia\ncr_oromia &lt;- cr |&gt;\n  select(farm, region, cultivar, sev2) |&gt; #select é pra colunas\n  filter(region == \"Oromia\")\ncr_oromia\n\n# A tibble: 165 × 4\n    farm region cultivar  sev2\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n 1   286 Oromia Mixture   7.63\n 2   287 Oromia Mixture   9.39\n 3   288 Oromia Mixture   1.30\n 4   289 Oromia Mixture   9.79\n 5   290 Oromia Local    18.5 \n 6   291 Oromia Mixture  13.2 \n 7   292 Oromia Mixture   5.60\n 8   293 Oromia Mixture   1.06\n 9   294 Oromia Local    17.6 \n10   295 Oromia Mixture  15.4 \n# ℹ 155 more rows\n\n#Filtra SNNPR\ncr_pr &lt;- cr |&gt;\n  select(farm, region, cultivar, sev2) |&gt;#select é pra colunas\n  filter(region == \"SNNPR\")\ncr_pr\n\n# A tibble: 240 × 4\n    farm region cultivar  sev2\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n 1     1 SNNPR  Local    55.6 \n 2     2 SNNPR  Mixture  17.9 \n 3     3 SNNPR  Mixture   8.25\n 4     4 SNNPR  Local    46.1 \n 5     5 SNNPR  Local    12.3 \n 6     6 SNNPR  Mixture  19.9 \n 7     7 SNNPR  Mixture  11.9 \n 8     8 SNNPR  Local    55.6 \n 9     9 SNNPR  Local    11.6 \n10    10 SNNPR  Mixture  11.4 \n# ℹ 230 more rows\n\n\n\n\n\nAinda podemos gerar gráficos ggplot2 para cada subconjunto para uma melhor visualização dos dados. No caso utilizamos o boxplot através da função geom_boxplot(), também do pacote ggplot2.\nO box plot é uma representação gráfica que mostra a distribuição de um conjunto de dados de maneira resumida, destacando a mediana, os quartis e os outliers. Os componentes de um boxplot são:\n\nCaixa:\n\nQuartil Inferior (Q1): Marca os 25% mais baixos dos dados.\nMediana (Q2): O valor central dos dados (50%).\nQuartil Superior (Q3): Marca os 75% mais baixos dos dados.\n\nWhiskers:\n\nLinhas que se estendem dos quartis até o valor mínimo e máximo dentro de 1.5 vezes o intervalo interquartil (IQR).\n\nOutliers:\n\nPontos fora do alcance dos whiskers, indicando valores atípicos.\n\n\n\ncr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2))+\n  geom_boxplot()+\n  labs(title = \"Oromia\",\n       X = \"Cultivar\",\n       y = \"Severity (%)\")\n\n\n\n\n\n\n\n\n\ncr_pr |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2))+\n  geom_boxplot()+\n  labs(title = \"SNNPR\",\n       X = \"Cultivar\",\n       y = \"Severity (%)\")\n\n\n\n\n\n\n\n\nO box plot é útil para identificar a mediana, a dispersão, a assimetria e os outliers em um conjunto de dados, facilitando a comparação entre diferentes grupos ou categorias.\n\n\n\nGráficos exibidos lado a lado podem auxiliar na percepção de diferença entre dois grupos quando queremos apresenta-las ao leitor de um artigo, por exemplo. Assim, para plotar dois gráficos lado a lado iremos utilizar a biblioteca patchwork, sem usar o face_wrap.\n\np1 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")#+ #lembrar de tirar o comentário do +\n  #coord_flip() #rotaciona as coordenadas\n\np2 &lt;- cr_pr |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")#+ #lembrar de tirar o comentário do +\n  coord_flip() #rotaciona as coordenadas\n\n&lt;ggproto object: Class CoordFlip, CoordCartesian, Coord, gg&gt;\n    aspect: function\n    backtransform_range: function\n    clip: on\n    default: FALSE\n    distance: function\n    expand: TRUE\n    is_free: function\n    is_linear: function\n    labels: function\n    limits: list\n    modify_scales: function\n    range: function\n    render_axis_h: function\n    render_axis_v: function\n    render_bg: function\n    render_fg: function\n    setup_data: function\n    setup_layout: function\n    setup_panel_guides: function\n    setup_panel_params: function\n    setup_params: function\n    train_panel_guides: function\n    transform: function\n    super:  &lt;ggproto object: Class CoordFlip, CoordCartesian, Coord, gg&gt;\n\nlibrary(patchwork)\n\n(p1 + p2) + #Pode ser + ou |, se colocar / coloca um sobre o outro. Ele funciona como equação, pode ser feito combinação dos gráficos como p1/(p2+p1)\nplot_layout(guides = \"collect\") + #Deixa somente uma legenda\nplot_annotation(tag_levels = \"A\") #Diferencia maiúsculas e minúsculas\n\n\n\n\n\n\n\nggsave(\"patch.png\")\n\nSaving 7 x 5 in image\n\n\nPodemos usar o artifício da função coord_flip(), para rotacionar as coordenadas de uma imagem ou das duas, caso fique visualmente mais adequado para a explicação dos dados.\n\np1 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  theme_few() +\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")+\n  coord_flip() #rotaciona as coordenadas\n\np2 &lt;- cr_pr |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  theme_few() +\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")+\n  coord_flip() #rotaciona as coordenadas\n\n#Não consegui instalar o patchwork\nlibrary(patchwork)\n\n(p1 / p2) + #pode ser + ou |, se colocar / coloca um sobre o outro. Ele funciona como equação, pode ser feito combinação dos gráficos como p1/(p2+p1)\nplot_layout(guides = \"collect\",\n            axes = \"collect\")+ #Deixa somente uma legenda\nplot_annotation(title = \"Coffe rust is Ethiopia\",\n                caption = \"source: Serafini (2024)\",\n                tag_levels = \"A\") #diferencia maiúsculas e minúsculas\n\n\n\n\n\n\n\nggsave(\"patch2.png\", width = 5, height = 4)\n\nOutra opção de combinações que o pacote permite é a sobreposição de gráficos através da função inset_element(), onde é inserido o gráfico que se deseja plotar e as dimensões/posições deste na imagem. Este é um excelente artifício para exibir informações gráficas complementares em uma mesma imagem.\n\np1 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = cultivar,\n             y = sev2,\n             fill = cultivar))+\n  geom_boxplot()+\n  theme_few() +\n  labs(x = \"Cultivar\",\n       y = \"Severity (%)\")+\n  coord_flip() #rotaciona as coordenadas\n\np3 &lt;- cr_oromia |&gt;\n  ggplot(aes(x = sev2))+\n  geom_histogram() +\n  labs(y = \"Freq.\",\n       x = \"Severity (%)\")\n\np1 + inset_element(p3, left = 0.6,\n                    bottom = 0.6,\n                    right = 1,\n                    top = 1) +\n  plot_annotation(title = \"Coffe rust is Ethiopia\",\n                caption = \"source: Serafini (2024)\",\n                tag_levels = \"A\") #diferencia maiúsculas e minúsculas\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nggsave(\"patch3.png\", width = 5, height = 4)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nO patchwork tem várias possíbilidades interessantes, vale a pena olhar a ajuda (help) deste pacote!"
  },
  {
    "objectID": "aula_06.html",
    "href": "aula_06.html",
    "title": "Análise Estatística: Estatística inferencial",
    "section": "",
    "text": "Iniciaremos este tópico importando o dataset que iremos trabalhar.\n\nlibrary(gsheet)\nmg = gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=983033137\")\n\nO pacote gsheet permite importar dados diretamente de uma planilha do Google Sheets. A função gsheet2tbl converte a planilha em um tibble (um tipo de data frame otimizado).\nCaso haja dúvidas, existe um tópico específico tratando da importação dos dados neste site.\n\n\n\n\n\nUm boxplot, também conhecido como diagrama de caixa, é uma representação gráfica que resume a distribuição de um conjunto de dados baseado em cinco estatísticas: mínimo, primeiro quartil (Q1), mediana (Q2), terceiro quartil (Q3) e máximo e também pode destacar outliers.\nO pacote tidyverse engloba diversos pacotes, como o ggplot2 que é uma das bibliotecas mais populares para visualização de dados em R. Com esta biblioteca podemos utilizar a função geom_boxplot que cria um boxplot. Podemos aplicar temas aplicando um tema preto e branco ao gráfico, melhorando a clareza visual com a função theme_bw().\nUm exemplo de boxplot pode ser plotado utilizando os dados já carregados acima:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nmg |&gt; \n  ggplot(aes(trat, comp))+\n  geom_boxplot()+\n  theme_bw()\n\n\n\n\n\n\n\n\nO boxplot é útil para visualizar a distribuição dos dados, incluindo a mediana, os quartis e possíveis outliers. O boxplot ainda pode ajuda a identificar a dispersão dos dados e a presença de possíveis valores atípicos. Além disso podemos identificar a diferença entre dois tratamentos usando um boxplot, começando pela observação a linha mediana dentro de cada caixa, que representa o valor central dos dados.\nComo as medianas estão em diferentes níveis, isso sugere que as medianas dos tratamentos são diferentes. Em seguida, examinamos a posição e a extensão das caixas (intervalo interquartil, IQR), e como as caixas dos dois tratamentos não se sobrepõem, as distribuições dos tratamentos são similares. Menos sobreposição indica uma maior probabilidade de diferença significativa entre os tratamentos.\n\n\n\n\nO Teste t é utilizado para comparar as médias de duas amostras, enquanto o Teste F, que veremos mais abaixo, seria para três ou mais. Ele verifica se a diferença entre as médias é estatisticamente significativa, ou seja, se é provável que as diferenças observadas se devam ao acaso.\n\n\nNo nosso exemplo, precisamos separar os dados para isso devemos passar do formato longo para o formato largo. A função pivot_wider transforma os dados de formato longo para formato largo. No formato longo, cada linha é uma observação única, enquanto no formato largo, cada linha representa um grupo de observações.\n\nmg2 &lt;- mg |&gt; \n  pivot_wider(names_from = trat, values_from = comp)\n\n\n\n\nA função t.test(),como o próprio nomde diz, realiza o teste t, que compara as médias de duas amostras para determinar se elas são estatisticamente diferentes. Um p-valor baixo (geralmente &lt; 0,05) indica que as médias são significativamente diferentes.\n\n# Teste t\nteste1 &lt;- t.test(mg2$Mg2, mg2$control)\nteste1\n\n\n    Welch Two Sample t-test\n\ndata:  mg2$Mg2 and mg2$control\nt = -8.1549, df = 17.354, p-value = 2.423e-07\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -6.490393 -3.825607\nsample estimates:\nmean of x mean of y \n   10.520    15.678 \n\n\n\n\nA hipótese H0, também conhecida como hipótese nula, é uma afirmação inicial que presume que não há efeito ou diferença significativa em um estudo ou experimento. É uma posição de “inocência” até que evidências suficientes provem o contrário. Na prática estatística, a hipótese nula é formulada para ser testada e possivelmente rejeitada em favor de uma hipótese alternativa (H1), que sugere a existência de um efeito ou diferença.\nNo caso do exemplo acima, nossa hiótese é de que as médias dos tratamentos não diferem entre si. Como o p-valor ou p-value foi menor do que 0,05, rejeitamos nossa hipótese nula (H0) e aceitamos a hípotese alternativa (H1), que no caso as médias dos tratamentos diferem entre si.\n\n\n\n\nA função shapiro.test(), testa a hipótese de que os dados vêm de uma distribuição normal. A normalidade dos dados é um pressuposto importante para a validade do teste t.\n\nshapiro.test(mg2$control)\n\n\n    Shapiro-Wilk normality test\n\ndata:  mg2$control\nW = 0.93886, p-value = 0.5404\n\nshapiro.test(mg2$Mg2)\n\n\n    Shapiro-Wilk normality test\n\ndata:  mg2$Mg2\nW = 0.97269, p-value = 0.9146\n\n\nUm p-valor alto indica que os dados são normalmente distribuídos, como ocorre no caso acima.\n\n\n\nA função hist() é utilizada para criar um histograma, que mostra a distribuição dos dados. É útil para visualizar a forma da distribuição e identificar se ela é aproximadamente normal.\n\n# Histograma\nhist(mg2$control)\n\n\n\n\n\n\n\nhist(mg2$Mg2)\n\n\n\n\n\n\n\n\nO histograma do tratamento controle segue nitidamente uma distribuição Gaussiana, enquanto a distribuição do tratamento Mg2 não segue uma distribuição normal.\n\n\n\nA função var.test() realiza a comparação das variâncias de duas amostras para verificar se são homogeneamente distribuídas. A homogeneidade de variância é outro pressuposto importante para os testes estatísticos.\n\n#Teste de homogêneidade de variância\nvar.test(mg2$control, mg2$Mg2) #Se a variância não for homogênea tem que informar, var.equal = FALSE\n\n\n    F test to compare two variances\n\ndata:  mg2$control and mg2$Mg2\nF = 0.67654, num df = 9, denom df = 9, p-value = 0.5698\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1680428 2.7237436\nsample estimates:\nratio of variances \n         0.6765394 \n\n\nUm p-valor alto indica que as variâncias são homogêneas, como ocorre no exemplo acima (p-value = 0.5698).\n\n\n\nA função qqplot() é uma ferramenta valiosa para comparar distribuições de dados. Ela é amplamente usada para verificar a normalidade de uma amostra e para comparar distribuições de viariância de duas amostras diferentes. A interpretação do QQ plot é baseada no quão bem os pontos seguem uma linha reta, com desvios significativos indicando diferenças entre as distribuições.\n\nqqplot(mg2$control, mg2$Mg2)\n\n\n\n\n\n\n\n\n\n\n\nO reaport() gera um relatório detalhado dos resultados do teste t pareado.\n\nlibrary(report)\n\nWarning: pacote 'report' foi compilado no R versão 4.4.1\n\nreport(teste1)\n\nWarning: Function `format_text()` is deprecated and will be removed in a future\n  release. Please use `text_format()` instead.\n\n\nEffect sizes were labelled following Cohen's (1988) recommendations.\n\nThe Welch Two Sample t-test testing the difference between mg2$Mg2 and\nmg2$control (mean of x = 10.52, mean of y = 15.68) suggests that the effect is\nnegative, statistically significant, and large (difference = -5.16, 95% CI\n[-6.49, -3.83], t(17.35) = -8.15, p &lt; .001; Cohen's d = -3.65, 95% CI [-5.12,\n-2.14])\n\n\nUtilizamos o teste t para sabermos se há diferença entre as médias, o p-valor foi &lt;0,05, porém temos que calcular se as médias possuem normalidade, para saber se podemos confiar no teste t. Segundo o teste de shapiro-wilk os dados seguem normalidade (não rejeita Ho), quando plotamos o histograma dos dados podemos observar que segue uma distribuição normal.\nOutra observação que devemos fazer é se as variáveis são homogênas usando o teste F. E neste caso as variâncias são homogêneas (não rejeita Ho) e o boxplot já dava esses indicativos visuais. Podemos fazer também o grafico QQ Plot para mostras a variância dos dados, como foi realizado acima.\n\n\n\n\nPara dados dependentes, realiza-se um teste t pareado. Esse teste é usado quando as amostras são dependentes, como medições antes e depois do tratamento no mesmo grupo de indivíduos. Para fazer o teste t pareado tem que colocar o argumento paired = TRUE no código.\n\n\nInicialmente devemos importar e visualizar os dados, lembrando que gsheet() importa dados do Google Sheets e ggplot2 e geom_boxplot() cria um boxplot para visualização.\n\nlibrary(gsheet)\nescala = gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1729131173\")\n\nescala |&gt; \n  ggplot(aes(assessment, acuracia))+\n  geom_boxplot()+\n  theme_bw()\n\n\n\n\n\n\n\n\nO boxplot, nos indica que há diferença entre os tratamentos, caso haja dúvidas sobre a interpretação há um tópico acima sobre a interpretação do boxplot.\n\n\n\nAntes de realizarmos os testes é necessário preparar os dados, selecionando as colunas específicas através da função select(). Além disso devemos transformar os dados de formato longo para formato largo pela função pivot_wider().\n\nescala2 &lt;- escala |&gt; \n  select(assessment, rater, acuracia) |&gt; \n  pivot_wider(names_from = assessment,\n              values_from = acuracia)\n\n\n\n\nPara o teste t pareado, temos que lembrar de colocar o argumento paried = TRUE, que por default ele vem como FALSE, este argumento indica que as amostras são pareadas. Assim, a função t.test(paired = TRUE) realiza um teste t pareado, que é usado quando as amostras são dependentes.\n\n#Tete t pareado\nteste2 &lt;- t.test(escala2$Aided1, escala2$Unaided, paried = TRUE, var.equal = FALSE)\n#Obs.: Os dados foram alterados para dar não paramétrico.\nteste2\n\n\n    Welch Two Sample t-test\n\ndata:  escala2$Aided1 and escala2$Unaided\nt = 4.4134, df = 9.8561, p-value = 0.001354\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.1161235 0.3538765\nsample estimates:\nmean of x mean of y \n    0.917     0.682 \n\n\nOs dados foram alterados para que pudessemos fazer uma análise não paramétrica. Portanto, pelo teste de homogeneidade, os dados não possuem homogêneidade de variância e assim temos que colocar var.equal = FALSE. A função var.equal = FALSE indica que as variâncias das duas amostras não são iguais, ajustando o cálculo do teste t para essa condição.\nO p-valor pelo teste t pareado é igaual a 0.001354, logo. com o p-valor &lt; 0.05, rejeitase H0 a 5% de probabiliade pelo teste t pareado.\n\n\n\nUsamos a função shapiro.test(), que testa a normalidade dos dados em cada grupo. Para mais detalhes sobre normalidade, veja nos tópicos acima.\n\n#Teste de normalidade\nshapiro.test(escala2$Unaided)\n\n\n    Shapiro-Wilk normality test\n\ndata:  escala2$Unaided\nW = 0.7748, p-value = 0.007155\n\nshapiro.test(escala2$Aided1)\n\n\n    Shapiro-Wilk normality test\n\ndata:  escala2$Aided1\nW = 0.92852, p-value = 0.4335\n\n\nSegundo o teste de normalidade de Shapiro-Wilk, a variável Unaided não segue uma distribuição normal (p-valor &lt; 0.05), enquanto a variável Aided1 apresentou normalidade (p-valor &gt; 0.05).\n\n\n\nA função hist() cria histogramas para visualizar a distribuição dos dados.\n\n#Histograma\nhist(escala2$Unaided)\n\n\n\n\n\n\n\nhist(escala2$Aided1)\n\n\n\n\n\n\n\n\nObservando os plots dos histogramas, ambas as variáveis Unaided e Aided, não possuem uma distribuição normal. Apesar da variável Aided1 ter apresentado normalidade (p-valor &gt; 0.05) pelo teste de Shapiro-Wilk. Em experimentos, costuma-se considerar os testes em detrimento dos gráficos.\n\n\n\nA função var.test() compara as variâncias dos dois grupos.\n\n#Teste de homogêneidade de variância\nvar.test(escala2$Unaided, escala2$Aided1) #Se a variância não for homogênea tem que informar, var.equal = FALSE\n\n\n    F test to compare two variances\n\ndata:  escala2$Unaided and escala2$Aided1\nF = 20.978, num df = 9, denom df = 9, p-value = 0.000106\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n  5.210754 84.459185\nsample estimates:\nratio of variances \n          20.97847 \n\n#qqplot(escala2$control, escala2$Aided1)\n\nPara o nosso exemplo, utilizamos o teste F para comparação de duas variâncias, que apresentou um p-valor &lt; 0.05, ou seja, rejeita-se H0 e aceita-se H1, as variâncias não apresentam homogeneidade pelo teste F a 5% de probabilidade.\n\n\n\nComo já mencionado, o R possui o pacote report, que por sua vez possui a função report(), que faz um sumário do teste armazenado em um objeto. No nosso exemplo:\n\nreport(teste2)\n\nWarning: Function `format_text()` is deprecated and will be removed in a future\n  release. Please use `text_format()` instead.\n\n\nEffect sizes were labelled following Cohen's (1988) recommendations.\n\nThe Welch Two Sample t-test testing the difference between escala2$Aided1 and\nescala2$Unaided (mean of x = 0.92, mean of y = 0.68) suggests that the effect\nis positive, statistically significant, and large (difference = 0.23, 95% CI\n[0.12, 0.35], t(9.86) = 4.41, p = 0.001; Cohen's d = 1.97, 95% CI [0.72, 3.18])\n\n\n\n\n\nQuando os dados não atendem aos pressupostos do teste t (normalidade e homogeneidade de variância), pode-se usar uma alternativa não paramétrica, como o teste de Wilcoxon que é um teste equivalente ao teste t, mas não assume uma distribuição normal dos dados.\nPara isso, utilizamos a função wilcox.test(), uma função nativa do R. Esta função realiza o teste de Wilcoxon, entretanto a a necessidade de colocar o parametro paired = TRUE para amostras pareadas.\n\nteste3 &lt;- wilcox.test(escala2$Aided1,\n            escala2$Unaided,\n            paired = TRUE) #Lembrar que é dado pareado, logo paired = TRUE\n\nWarning in wilcox.test.default(escala2$Aided1, escala2$Unaided, paired = TRUE):\nnão é possível computar o valor de p exato com o de desempate\n\nteste3\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  escala2$Aided1 and escala2$Unaided\nV = 55, p-value = 0.005889\nalternative hypothesis: true location shift is not equal to 0\n\n\n\n\n\n\nPara comparar três ou mais grupos, utiliza-se o teste f através da ANOVA (Análise de Variância), que verifica se há diferenças significativas entre as médias de mais de dois grupos.\n\n\nSempre inciamos importando os dados, para maiores informações sobre como importar os dados, verifique o tópico específico. O mesmo é valido para o boxplot.\n\nmicelial = gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=959387827\")\n\nmicelial |&gt; \n  ggplot(aes(especie, tcm))+\n  geom_boxplot()+\n  theme_bw()\n\n\n\n\n\n\n\n\nAnálisando o box-plot, ao menos dois tratamentos diferem das demais, Fasi e Fgra. Entretanto, é necessário que sejam feitos testes para saber realmente há diferença e se seguem os pressupostos de normalidade e homogeneidade.\n\n\n\nPara realizarmos a ANOVA, podemos usar a função aov() ou lm(). Neste exemplo usaremos a função lm(), que cria um modelo linear que relaciona a variável de interesse (tcm) com os grupos (especie). Ao colocarmos espécie -1 já é calculada a média da estimativa.\nA função anova() realiza a análise de variância (ANOVA), que compara as médias de três ou mais grupos para determinar se há diferenças significativas.\n\nm1 &lt;- lm(tcm ~ especie -1, data = micelial)\nanova(m1)\n\nAnalysis of Variance Table\n\nResponse: tcm\n          Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nespecie    5 51.677 10.3354   552.2 &lt; 2.2e-16 ***\nResiduals 25  0.468  0.0187                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nshapiro.test(m1$residuals)\n\n\n    Shapiro-Wilk normality test\n\ndata:  m1$residuals\nW = 0.9821, p-value = 0.8782\n\nbartlett.test(tcm ~ especie, data = micelial)\n\n\n    Bartlett test of homogeneity of variances\n\ndata:  tcm by especie\nBartlett's K-squared = 4.4367, df = 4, p-value = 0.3501\n\n\nSegundo os testes de Shapiro-Wilk, e Bartelett os dados apresentam normalidade e homogeneidade de variância, respectivamente, a 5% de probailidade (p-valor &gt; 0.05). Segundo a ANOVA, ao menos uma das médias difere das demais pelo teste F ao nível de 5% de probabilidade (p-valor &gt; 0.05).\n\n\nA função summary() fornece um resumo estatístico do modelo linear, incluindo coeficientes, erros padrão, valores t e p-valores.\n\nsummary(m1)\n\n\nCall:\nlm(formula = tcm ~ especie - 1, data = micelial)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.23667 -0.09667  0.01583  0.08833  0.28333 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \nespecieFasi  1.57167    0.05585   28.14  &lt; 2e-16 ***\nespecieFaus  1.23667    0.05585   22.14  &lt; 2e-16 ***\nespecieFcor  1.32167    0.05585   23.66  &lt; 2e-16 ***\nespecieFgra  0.91167    0.05585   16.32 7.66e-15 ***\nespecieFmer  1.42667    0.05585   25.54  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1368 on 25 degrees of freedom\nMultiple R-squared:  0.991, Adjusted R-squared:  0.9892 \nF-statistic: 552.2 on 5 and 25 DF,  p-value: &lt; 2.2e-16\n\n\nOs resultados indicam que todas as espécies têm médias estimadas de tcm significativamente diferentes de zero (p &lt; 0.001 para todas). O modelo ajustado explica 99.1% da variabilidade total dos dados (R-squared = 0.991).\nA ANOVA sugere que há diferenças significativas nas médias de tcm entre as espécies (p &lt; 2.2e-16). O modelo apresenta um bom ajuste com um erro padrão residual baixo (0.1368) e coeficientes altamente significativos.\n\n\n\n\nPara comparar as médias dos grupos, usamos o pacote emmeans. Este pacote calcula as estimativas marginais dos efeitos e facilita a comparação entre os grupos.\nO pacote multcomp é utilizado para realizar comparações múltiplas entre as médias dos grupos. A função cld() gera diferenciadores compactos que indicam quais médias são significativamente diferentes entre si.\n\nlibrary(emmeans)\n\nWarning: pacote 'emmeans' foi compilado no R versão 4.4.1\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\nmedias1 &lt;- emmeans(m1, ~ especie)\nmedias1\n\n especie emmean     SE df lower.CL upper.CL\n Fasi     1.572 0.0559 25    1.457     1.69\n Faus     1.237 0.0559 25    1.122     1.35\n Fcor     1.322 0.0559 25    1.207     1.44\n Fgra     0.912 0.0559 25    0.797     1.03\n Fmer     1.427 0.0559 25    1.312     1.54\n\nConfidence level used: 0.95 \n\nlibrary(multcomp)\n\nCarregando pacotes exigidos: mvtnorm\n\n\nCarregando pacotes exigidos: survival\n\n\nWarning: pacote 'survival' foi compilado no R versão 4.4.1\n\n\nCarregando pacotes exigidos: TH.data\n\n\nCarregando pacotes exigidos: MASS\n\n\nWarning: pacote 'MASS' foi compilado no R versão 4.4.1\n\n\n\nAnexando pacote: 'MASS'\n\n\nO seguinte objeto é mascarado por 'package:dplyr':\n\n    select\n\n\n\nAnexando pacote: 'TH.data'\n\n\nO seguinte objeto é mascarado por 'package:MASS':\n\n    geyser\n\nlibrary(multcompView)\n\nWarning: pacote 'multcompView' foi compilado no R versão 4.4.1\n\ncld(medias1)\n\n especie emmean     SE df lower.CL upper.CL .group\n Fgra     0.912 0.0559 25    0.797     1.03  1    \n Faus     1.237 0.0559 25    1.122     1.35   2   \n Fcor     1.322 0.0559 25    1.207     1.44   2   \n Fmer     1.427 0.0559 25    1.312     1.54   23  \n Fasi     1.572 0.0559 25    1.457     1.69    3  \n\nConfidence level used: 0.95 \nP value adjustment: tukey method for comparing a family of 5 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n\n\nSegundo a tabela acima foram formados 3 grupos, a espécie Fgra diferenciou-se das demais com menor tcm, enquanto Faus, Fcor e Fmer formaram outro grupo, entretanto Fmer e Fasi não diferiram entre si, formando um grupo.\n\n\n\nUtilizamos o pacote DHARMa para gerar gráficos de resíduos simulados e verificar a adequação do modelo. Este pacote possui a função simulateResiduals(), que simula resíduos para verificar a adequação do modelo. A exibição é realizada pela função plot(), que plota os resíduos simulados para diagnóstico visual.\n\nlibrary(DHARMa)\n\nWarning: pacote 'DHARMa' foi compilado no R versão 4.4.1\n\n\nThis is DHARMa 0.4.6. For overview type '?DHARMa'. For recent changes, type news(package = 'DHARMa')\n\nplot(simulateResiduals(m1))\n\n\n\n\n\n\n\n\nOs gráficos de resíduos fornecidos pelo pacote DHARMa ajudam a diagnosticar possíveis problemas com o modelo. O gráfico de quantil-quantil (QQ plot) compara os resíduos observados com os esperados sob uma distribuição normal.\nAinda no gráfico, os pontos devem estar próximos da linha diagonal. Se estiverem, isso indica que os resíduos são aproximadamente normais. No gráfico do exemplo, os pontos seguem de perto a linha, indicando que os resíduos são aproximadamente normais.\nO gráfico Residuals vs. Predicted mostra os resíduos plotados contra os valores preditos. Uma distribuição aleatória dos pontos ao redor da linha horizontal (em zero) sugere que não há padrões sistemáticos nos resíduos.\nNo gráfico do exemplo, os pontos estão bem distribuídos, sugerindo que não há problemas significativos de heteroscedasticidade ou não-linearidade.\nAlém disso, o pacote DHARMa fornece análise de normalidade e homogeneidade e plota junto ao seu respectivo gráfico.\nApós, verificamos os pressupostos do modelo com o pacote performance. A função check_normality() verifica a normalidade dos resíduos, check_heteroscedasticity() verifica a presença de heteroscedasticidade e a função check_model() realiza verificações abrangentes do modelo, incluindo normalidade, heteroscedasticidade e outros diagnósticos.\n\nlibrary(performance)\n\nWarning: pacote 'performance' foi compilado no R versão 4.4.1\n\ncheck_normality(m1)\n\nOK: residuals appear as normally distributed (p = 0.878).\n\ncheck_heteroscedasticity(m1)\n\nOK: Error variance appears to be homoscedastic (p = 0.880).\n\ncheck_model(m1)\n\n\n\n\n\n\n\n\nO gráficoPosterior Predictive Check compara a densidade dos dados observados com as densidades preditas pelo modelo. As linhas azuis representam as predições do modelo e a linha verde representa os dados observados. Se as linhas preditas (azuis) estiverem próximas à linha dos dados observados (verde), isso sugere que o modelo se ajusta bem aos dados. No gráfico do exemplo, as linhas azuis estão próximas à linha verde, indicando um bom ajuste do modelo.\nO gráfico Linearity (Linearidade) exibe resíduos padronizados versus valores ajustados. A linha de referência deve ser plana e horizontal e os pontos devem estar distribuídos aleatoriamente ao redor da linha horizontal. No gráfico do exemplo, os pontos parecem estar distribuídos aleatoriamente, indicando que o pressuposto de linearidade é atendido.\nO gráfico Homogeneity of Variance (Homoscedasticidade) exibe os resíduos padronizados versus valores ajustados. A linha de referência também deve ser plana e horizontal e os resíduos devem ter variância constante em todos os níveis de valores ajustados. No gráfico do exemplo, os pontos estão distribuídos de maneira uniforme ao redor da linha, indicando homoscedasticidade.\nO gráfico Normality of Residuals (Normalidade dos Resíduos) exibe o QQ plot dos resíduos padronizados. Os pontos devem estar alinhados ao longo da linha diagonal, se os pontos seguem a linha diagonal, isso indica que os resíduos são normalmente distribuídos. No gráfico do exemplo, os pontos estão relativamente alinhados à linha, indicando que os resíduos são aproximadamente normais.\nPor fim, o gráfico Influential Observations (Observações Influentes) exibe os resíduos padronizados versus leverage (hi). As observações devem estar dentro das linhas de contorno, este gráfico ajuda a identificar observações que têm uma influência desproporcional no ajuste do modelo. No gráfico do exemplo, a maioria dos pontos está dentro das linhas de contorno, indicando que não há observações influentes significativas.\n\n\nOs gráficos de diagnóstico do exemplo indicam que o modelo ajustado atende aos pressupostos necessários para uma análise de regressão válida:\n\nLinearidade: O pressuposto de linearidade é atendido, pois os resíduos são distribuídos aleatoriamente ao redor da linha horizontal.\nHomoscedasticidade: A variância dos resíduos é constante, conforme indicado pela distribuição uniforme dos pontos.\nNormalidade dos Resíduos: Os resíduos são aproximadamente normais, conforme indicado pelo QQ plot.\nObservações Influentes: Não há observações influentes significativas que possam distorcer os resultados do modelo.\n\nEsses resultados sugerem que o modelo é bem ajustado e que as inferências feitas a partir dele são confiáveis."
  },
  {
    "objectID": "aula_06.html#importando-os-dados",
    "href": "aula_06.html#importando-os-dados",
    "title": "Análise Estatística: Estatística inferencial",
    "section": "",
    "text": "Iniciaremos este tópico importando o dataset que iremos trabalhar.\n\nlibrary(gsheet)\nmg = gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=983033137\")\n\nO pacote gsheet permite importar dados diretamente de uma planilha do Google Sheets. A função gsheet2tbl converte a planilha em um tibble (um tipo de data frame otimizado).\nCaso haja dúvidas, existe um tópico específico tratando da importação dos dados neste site."
  },
  {
    "objectID": "aula_06.html#visualização-dos-dados",
    "href": "aula_06.html#visualização-dos-dados",
    "title": "Análise Estatística: Estatística inferencial",
    "section": "",
    "text": "Um boxplot, também conhecido como diagrama de caixa, é uma representação gráfica que resume a distribuição de um conjunto de dados baseado em cinco estatísticas: mínimo, primeiro quartil (Q1), mediana (Q2), terceiro quartil (Q3) e máximo e também pode destacar outliers.\nO pacote tidyverse engloba diversos pacotes, como o ggplot2 que é uma das bibliotecas mais populares para visualização de dados em R. Com esta biblioteca podemos utilizar a função geom_boxplot que cria um boxplot. Podemos aplicar temas aplicando um tema preto e branco ao gráfico, melhorando a clareza visual com a função theme_bw().\nUm exemplo de boxplot pode ser plotado utilizando os dados já carregados acima:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nmg |&gt; \n  ggplot(aes(trat, comp))+\n  geom_boxplot()+\n  theme_bw()\n\n\n\n\n\n\n\n\nO boxplot é útil para visualizar a distribuição dos dados, incluindo a mediana, os quartis e possíveis outliers. O boxplot ainda pode ajuda a identificar a dispersão dos dados e a presença de possíveis valores atípicos. Além disso podemos identificar a diferença entre dois tratamentos usando um boxplot, começando pela observação a linha mediana dentro de cada caixa, que representa o valor central dos dados.\nComo as medianas estão em diferentes níveis, isso sugere que as medianas dos tratamentos são diferentes. Em seguida, examinamos a posição e a extensão das caixas (intervalo interquartil, IQR), e como as caixas dos dois tratamentos não se sobrepõem, as distribuições dos tratamentos são similares. Menos sobreposição indica uma maior probabilidade de diferença significativa entre os tratamentos."
  },
  {
    "objectID": "aula_06.html#teste-t---dados-independentes",
    "href": "aula_06.html#teste-t---dados-independentes",
    "title": "Análise Estatística: Estatística inferencial",
    "section": "",
    "text": "O Teste t é utilizado para comparar as médias de duas amostras, enquanto o Teste F, que veremos mais abaixo, seria para três ou mais. Ele verifica se a diferença entre as médias é estatisticamente significativa, ou seja, se é provável que as diferenças observadas se devam ao acaso.\n\n\nNo nosso exemplo, precisamos separar os dados para isso devemos passar do formato longo para o formato largo. A função pivot_wider transforma os dados de formato longo para formato largo. No formato longo, cada linha é uma observação única, enquanto no formato largo, cada linha representa um grupo de observações.\n\nmg2 &lt;- mg |&gt; \n  pivot_wider(names_from = trat, values_from = comp)\n\n\n\n\nA função t.test(),como o próprio nomde diz, realiza o teste t, que compara as médias de duas amostras para determinar se elas são estatisticamente diferentes. Um p-valor baixo (geralmente &lt; 0,05) indica que as médias são significativamente diferentes.\n\n# Teste t\nteste1 &lt;- t.test(mg2$Mg2, mg2$control)\nteste1\n\n\n    Welch Two Sample t-test\n\ndata:  mg2$Mg2 and mg2$control\nt = -8.1549, df = 17.354, p-value = 2.423e-07\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -6.490393 -3.825607\nsample estimates:\nmean of x mean of y \n   10.520    15.678 \n\n\n\n\nA hipótese H0, também conhecida como hipótese nula, é uma afirmação inicial que presume que não há efeito ou diferença significativa em um estudo ou experimento. É uma posição de “inocência” até que evidências suficientes provem o contrário. Na prática estatística, a hipótese nula é formulada para ser testada e possivelmente rejeitada em favor de uma hipótese alternativa (H1), que sugere a existência de um efeito ou diferença.\nNo caso do exemplo acima, nossa hiótese é de que as médias dos tratamentos não diferem entre si. Como o p-valor ou p-value foi menor do que 0,05, rejeitamos nossa hipótese nula (H0) e aceitamos a hípotese alternativa (H1), que no caso as médias dos tratamentos diferem entre si.\n\n\n\n\nA função shapiro.test(), testa a hipótese de que os dados vêm de uma distribuição normal. A normalidade dos dados é um pressuposto importante para a validade do teste t.\n\nshapiro.test(mg2$control)\n\n\n    Shapiro-Wilk normality test\n\ndata:  mg2$control\nW = 0.93886, p-value = 0.5404\n\nshapiro.test(mg2$Mg2)\n\n\n    Shapiro-Wilk normality test\n\ndata:  mg2$Mg2\nW = 0.97269, p-value = 0.9146\n\n\nUm p-valor alto indica que os dados são normalmente distribuídos, como ocorre no caso acima.\n\n\n\nA função hist() é utilizada para criar um histograma, que mostra a distribuição dos dados. É útil para visualizar a forma da distribuição e identificar se ela é aproximadamente normal.\n\n# Histograma\nhist(mg2$control)\n\n\n\n\n\n\n\nhist(mg2$Mg2)\n\n\n\n\n\n\n\n\nO histograma do tratamento controle segue nitidamente uma distribuição Gaussiana, enquanto a distribuição do tratamento Mg2 não segue uma distribuição normal.\n\n\n\nA função var.test() realiza a comparação das variâncias de duas amostras para verificar se são homogeneamente distribuídas. A homogeneidade de variância é outro pressuposto importante para os testes estatísticos.\n\n#Teste de homogêneidade de variância\nvar.test(mg2$control, mg2$Mg2) #Se a variância não for homogênea tem que informar, var.equal = FALSE\n\n\n    F test to compare two variances\n\ndata:  mg2$control and mg2$Mg2\nF = 0.67654, num df = 9, denom df = 9, p-value = 0.5698\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1680428 2.7237436\nsample estimates:\nratio of variances \n         0.6765394 \n\n\nUm p-valor alto indica que as variâncias são homogêneas, como ocorre no exemplo acima (p-value = 0.5698).\n\n\n\nA função qqplot() é uma ferramenta valiosa para comparar distribuições de dados. Ela é amplamente usada para verificar a normalidade de uma amostra e para comparar distribuições de viariância de duas amostras diferentes. A interpretação do QQ plot é baseada no quão bem os pontos seguem uma linha reta, com desvios significativos indicando diferenças entre as distribuições.\n\nqqplot(mg2$control, mg2$Mg2)\n\n\n\n\n\n\n\n\n\n\n\nO reaport() gera um relatório detalhado dos resultados do teste t pareado.\n\nlibrary(report)\n\nWarning: pacote 'report' foi compilado no R versão 4.4.1\n\nreport(teste1)\n\nWarning: Function `format_text()` is deprecated and will be removed in a future\n  release. Please use `text_format()` instead.\n\n\nEffect sizes were labelled following Cohen's (1988) recommendations.\n\nThe Welch Two Sample t-test testing the difference between mg2$Mg2 and\nmg2$control (mean of x = 10.52, mean of y = 15.68) suggests that the effect is\nnegative, statistically significant, and large (difference = -5.16, 95% CI\n[-6.49, -3.83], t(17.35) = -8.15, p &lt; .001; Cohen's d = -3.65, 95% CI [-5.12,\n-2.14])\n\n\nUtilizamos o teste t para sabermos se há diferença entre as médias, o p-valor foi &lt;0,05, porém temos que calcular se as médias possuem normalidade, para saber se podemos confiar no teste t. Segundo o teste de shapiro-wilk os dados seguem normalidade (não rejeita Ho), quando plotamos o histograma dos dados podemos observar que segue uma distribuição normal.\nOutra observação que devemos fazer é se as variáveis são homogênas usando o teste F. E neste caso as variâncias são homogêneas (não rejeita Ho) e o boxplot já dava esses indicativos visuais. Podemos fazer também o grafico QQ Plot para mostras a variância dos dados, como foi realizado acima."
  },
  {
    "objectID": "aula_06.html#teste-t---dados-dependentes",
    "href": "aula_06.html#teste-t---dados-dependentes",
    "title": "Análise Estatística: Estatística inferencial",
    "section": "",
    "text": "Para dados dependentes, realiza-se um teste t pareado. Esse teste é usado quando as amostras são dependentes, como medições antes e depois do tratamento no mesmo grupo de indivíduos. Para fazer o teste t pareado tem que colocar o argumento paired = TRUE no código.\n\n\nInicialmente devemos importar e visualizar os dados, lembrando que gsheet() importa dados do Google Sheets e ggplot2 e geom_boxplot() cria um boxplot para visualização.\n\nlibrary(gsheet)\nescala = gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1729131173\")\n\nescala |&gt; \n  ggplot(aes(assessment, acuracia))+\n  geom_boxplot()+\n  theme_bw()\n\n\n\n\n\n\n\n\nO boxplot, nos indica que há diferença entre os tratamentos, caso haja dúvidas sobre a interpretação há um tópico acima sobre a interpretação do boxplot.\n\n\n\nAntes de realizarmos os testes é necessário preparar os dados, selecionando as colunas específicas através da função select(). Além disso devemos transformar os dados de formato longo para formato largo pela função pivot_wider().\n\nescala2 &lt;- escala |&gt; \n  select(assessment, rater, acuracia) |&gt; \n  pivot_wider(names_from = assessment,\n              values_from = acuracia)\n\n\n\n\nPara o teste t pareado, temos que lembrar de colocar o argumento paried = TRUE, que por default ele vem como FALSE, este argumento indica que as amostras são pareadas. Assim, a função t.test(paired = TRUE) realiza um teste t pareado, que é usado quando as amostras são dependentes.\n\n#Tete t pareado\nteste2 &lt;- t.test(escala2$Aided1, escala2$Unaided, paried = TRUE, var.equal = FALSE)\n#Obs.: Os dados foram alterados para dar não paramétrico.\nteste2\n\n\n    Welch Two Sample t-test\n\ndata:  escala2$Aided1 and escala2$Unaided\nt = 4.4134, df = 9.8561, p-value = 0.001354\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.1161235 0.3538765\nsample estimates:\nmean of x mean of y \n    0.917     0.682 \n\n\nOs dados foram alterados para que pudessemos fazer uma análise não paramétrica. Portanto, pelo teste de homogeneidade, os dados não possuem homogêneidade de variância e assim temos que colocar var.equal = FALSE. A função var.equal = FALSE indica que as variâncias das duas amostras não são iguais, ajustando o cálculo do teste t para essa condição.\nO p-valor pelo teste t pareado é igaual a 0.001354, logo. com o p-valor &lt; 0.05, rejeitase H0 a 5% de probabiliade pelo teste t pareado.\n\n\n\nUsamos a função shapiro.test(), que testa a normalidade dos dados em cada grupo. Para mais detalhes sobre normalidade, veja nos tópicos acima.\n\n#Teste de normalidade\nshapiro.test(escala2$Unaided)\n\n\n    Shapiro-Wilk normality test\n\ndata:  escala2$Unaided\nW = 0.7748, p-value = 0.007155\n\nshapiro.test(escala2$Aided1)\n\n\n    Shapiro-Wilk normality test\n\ndata:  escala2$Aided1\nW = 0.92852, p-value = 0.4335\n\n\nSegundo o teste de normalidade de Shapiro-Wilk, a variável Unaided não segue uma distribuição normal (p-valor &lt; 0.05), enquanto a variável Aided1 apresentou normalidade (p-valor &gt; 0.05).\n\n\n\nA função hist() cria histogramas para visualizar a distribuição dos dados.\n\n#Histograma\nhist(escala2$Unaided)\n\n\n\n\n\n\n\nhist(escala2$Aided1)\n\n\n\n\n\n\n\n\nObservando os plots dos histogramas, ambas as variáveis Unaided e Aided, não possuem uma distribuição normal. Apesar da variável Aided1 ter apresentado normalidade (p-valor &gt; 0.05) pelo teste de Shapiro-Wilk. Em experimentos, costuma-se considerar os testes em detrimento dos gráficos.\n\n\n\nA função var.test() compara as variâncias dos dois grupos.\n\n#Teste de homogêneidade de variância\nvar.test(escala2$Unaided, escala2$Aided1) #Se a variância não for homogênea tem que informar, var.equal = FALSE\n\n\n    F test to compare two variances\n\ndata:  escala2$Unaided and escala2$Aided1\nF = 20.978, num df = 9, denom df = 9, p-value = 0.000106\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n  5.210754 84.459185\nsample estimates:\nratio of variances \n          20.97847 \n\n#qqplot(escala2$control, escala2$Aided1)\n\nPara o nosso exemplo, utilizamos o teste F para comparação de duas variâncias, que apresentou um p-valor &lt; 0.05, ou seja, rejeita-se H0 e aceita-se H1, as variâncias não apresentam homogeneidade pelo teste F a 5% de probabilidade.\n\n\n\nComo já mencionado, o R possui o pacote report, que por sua vez possui a função report(), que faz um sumário do teste armazenado em um objeto. No nosso exemplo:\n\nreport(teste2)\n\nWarning: Function `format_text()` is deprecated and will be removed in a future\n  release. Please use `text_format()` instead.\n\n\nEffect sizes were labelled following Cohen's (1988) recommendations.\n\nThe Welch Two Sample t-test testing the difference between escala2$Aided1 and\nescala2$Unaided (mean of x = 0.92, mean of y = 0.68) suggests that the effect\nis positive, statistically significant, and large (difference = 0.23, 95% CI\n[0.12, 0.35], t(9.86) = 4.41, p = 0.001; Cohen's d = 1.97, 95% CI [0.72, 3.18])\n\n\n\n\n\nQuando os dados não atendem aos pressupostos do teste t (normalidade e homogeneidade de variância), pode-se usar uma alternativa não paramétrica, como o teste de Wilcoxon que é um teste equivalente ao teste t, mas não assume uma distribuição normal dos dados.\nPara isso, utilizamos a função wilcox.test(), uma função nativa do R. Esta função realiza o teste de Wilcoxon, entretanto a a necessidade de colocar o parametro paired = TRUE para amostras pareadas.\n\nteste3 &lt;- wilcox.test(escala2$Aided1,\n            escala2$Unaided,\n            paired = TRUE) #Lembrar que é dado pareado, logo paired = TRUE\n\nWarning in wilcox.test.default(escala2$Aided1, escala2$Unaided, paired = TRUE):\nnão é possível computar o valor de p exato com o de desempate\n\nteste3\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  escala2$Aided1 and escala2$Unaided\nV = 55, p-value = 0.005889\nalternative hypothesis: true location shift is not equal to 0"
  },
  {
    "objectID": "aula_06.html#teste-f-para-três-ou-mais-grupos",
    "href": "aula_06.html#teste-f-para-três-ou-mais-grupos",
    "title": "Análise Estatística: Estatística inferencial",
    "section": "",
    "text": "Para comparar três ou mais grupos, utiliza-se o teste f através da ANOVA (Análise de Variância), que verifica se há diferenças significativas entre as médias de mais de dois grupos.\n\n\nSempre inciamos importando os dados, para maiores informações sobre como importar os dados, verifique o tópico específico. O mesmo é valido para o boxplot.\n\nmicelial = gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=959387827\")\n\nmicelial |&gt; \n  ggplot(aes(especie, tcm))+\n  geom_boxplot()+\n  theme_bw()\n\n\n\n\n\n\n\n\nAnálisando o box-plot, ao menos dois tratamentos diferem das demais, Fasi e Fgra. Entretanto, é necessário que sejam feitos testes para saber realmente há diferença e se seguem os pressupostos de normalidade e homogeneidade.\n\n\n\nPara realizarmos a ANOVA, podemos usar a função aov() ou lm(). Neste exemplo usaremos a função lm(), que cria um modelo linear que relaciona a variável de interesse (tcm) com os grupos (especie). Ao colocarmos espécie -1 já é calculada a média da estimativa.\nA função anova() realiza a análise de variância (ANOVA), que compara as médias de três ou mais grupos para determinar se há diferenças significativas.\n\nm1 &lt;- lm(tcm ~ especie -1, data = micelial)\nanova(m1)\n\nAnalysis of Variance Table\n\nResponse: tcm\n          Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nespecie    5 51.677 10.3354   552.2 &lt; 2.2e-16 ***\nResiduals 25  0.468  0.0187                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nshapiro.test(m1$residuals)\n\n\n    Shapiro-Wilk normality test\n\ndata:  m1$residuals\nW = 0.9821, p-value = 0.8782\n\nbartlett.test(tcm ~ especie, data = micelial)\n\n\n    Bartlett test of homogeneity of variances\n\ndata:  tcm by especie\nBartlett's K-squared = 4.4367, df = 4, p-value = 0.3501\n\n\nSegundo os testes de Shapiro-Wilk, e Bartelett os dados apresentam normalidade e homogeneidade de variância, respectivamente, a 5% de probailidade (p-valor &gt; 0.05). Segundo a ANOVA, ao menos uma das médias difere das demais pelo teste F ao nível de 5% de probabilidade (p-valor &gt; 0.05).\n\n\nA função summary() fornece um resumo estatístico do modelo linear, incluindo coeficientes, erros padrão, valores t e p-valores.\n\nsummary(m1)\n\n\nCall:\nlm(formula = tcm ~ especie - 1, data = micelial)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.23667 -0.09667  0.01583  0.08833  0.28333 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \nespecieFasi  1.57167    0.05585   28.14  &lt; 2e-16 ***\nespecieFaus  1.23667    0.05585   22.14  &lt; 2e-16 ***\nespecieFcor  1.32167    0.05585   23.66  &lt; 2e-16 ***\nespecieFgra  0.91167    0.05585   16.32 7.66e-15 ***\nespecieFmer  1.42667    0.05585   25.54  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1368 on 25 degrees of freedom\nMultiple R-squared:  0.991, Adjusted R-squared:  0.9892 \nF-statistic: 552.2 on 5 and 25 DF,  p-value: &lt; 2.2e-16\n\n\nOs resultados indicam que todas as espécies têm médias estimadas de tcm significativamente diferentes de zero (p &lt; 0.001 para todas). O modelo ajustado explica 99.1% da variabilidade total dos dados (R-squared = 0.991).\nA ANOVA sugere que há diferenças significativas nas médias de tcm entre as espécies (p &lt; 2.2e-16). O modelo apresenta um bom ajuste com um erro padrão residual baixo (0.1368) e coeficientes altamente significativos.\n\n\n\n\nPara comparar as médias dos grupos, usamos o pacote emmeans. Este pacote calcula as estimativas marginais dos efeitos e facilita a comparação entre os grupos.\nO pacote multcomp é utilizado para realizar comparações múltiplas entre as médias dos grupos. A função cld() gera diferenciadores compactos que indicam quais médias são significativamente diferentes entre si.\n\nlibrary(emmeans)\n\nWarning: pacote 'emmeans' foi compilado no R versão 4.4.1\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\nmedias1 &lt;- emmeans(m1, ~ especie)\nmedias1\n\n especie emmean     SE df lower.CL upper.CL\n Fasi     1.572 0.0559 25    1.457     1.69\n Faus     1.237 0.0559 25    1.122     1.35\n Fcor     1.322 0.0559 25    1.207     1.44\n Fgra     0.912 0.0559 25    0.797     1.03\n Fmer     1.427 0.0559 25    1.312     1.54\n\nConfidence level used: 0.95 \n\nlibrary(multcomp)\n\nCarregando pacotes exigidos: mvtnorm\n\n\nCarregando pacotes exigidos: survival\n\n\nWarning: pacote 'survival' foi compilado no R versão 4.4.1\n\n\nCarregando pacotes exigidos: TH.data\n\n\nCarregando pacotes exigidos: MASS\n\n\nWarning: pacote 'MASS' foi compilado no R versão 4.4.1\n\n\n\nAnexando pacote: 'MASS'\n\n\nO seguinte objeto é mascarado por 'package:dplyr':\n\n    select\n\n\n\nAnexando pacote: 'TH.data'\n\n\nO seguinte objeto é mascarado por 'package:MASS':\n\n    geyser\n\nlibrary(multcompView)\n\nWarning: pacote 'multcompView' foi compilado no R versão 4.4.1\n\ncld(medias1)\n\n especie emmean     SE df lower.CL upper.CL .group\n Fgra     0.912 0.0559 25    0.797     1.03  1    \n Faus     1.237 0.0559 25    1.122     1.35   2   \n Fcor     1.322 0.0559 25    1.207     1.44   2   \n Fmer     1.427 0.0559 25    1.312     1.54   23  \n Fasi     1.572 0.0559 25    1.457     1.69    3  \n\nConfidence level used: 0.95 \nP value adjustment: tukey method for comparing a family of 5 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n\n\nSegundo a tabela acima foram formados 3 grupos, a espécie Fgra diferenciou-se das demais com menor tcm, enquanto Faus, Fcor e Fmer formaram outro grupo, entretanto Fmer e Fasi não diferiram entre si, formando um grupo.\n\n\n\nUtilizamos o pacote DHARMa para gerar gráficos de resíduos simulados e verificar a adequação do modelo. Este pacote possui a função simulateResiduals(), que simula resíduos para verificar a adequação do modelo. A exibição é realizada pela função plot(), que plota os resíduos simulados para diagnóstico visual.\n\nlibrary(DHARMa)\n\nWarning: pacote 'DHARMa' foi compilado no R versão 4.4.1\n\n\nThis is DHARMa 0.4.6. For overview type '?DHARMa'. For recent changes, type news(package = 'DHARMa')\n\nplot(simulateResiduals(m1))\n\n\n\n\n\n\n\n\nOs gráficos de resíduos fornecidos pelo pacote DHARMa ajudam a diagnosticar possíveis problemas com o modelo. O gráfico de quantil-quantil (QQ plot) compara os resíduos observados com os esperados sob uma distribuição normal.\nAinda no gráfico, os pontos devem estar próximos da linha diagonal. Se estiverem, isso indica que os resíduos são aproximadamente normais. No gráfico do exemplo, os pontos seguem de perto a linha, indicando que os resíduos são aproximadamente normais.\nO gráfico Residuals vs. Predicted mostra os resíduos plotados contra os valores preditos. Uma distribuição aleatória dos pontos ao redor da linha horizontal (em zero) sugere que não há padrões sistemáticos nos resíduos.\nNo gráfico do exemplo, os pontos estão bem distribuídos, sugerindo que não há problemas significativos de heteroscedasticidade ou não-linearidade.\nAlém disso, o pacote DHARMa fornece análise de normalidade e homogeneidade e plota junto ao seu respectivo gráfico.\nApós, verificamos os pressupostos do modelo com o pacote performance. A função check_normality() verifica a normalidade dos resíduos, check_heteroscedasticity() verifica a presença de heteroscedasticidade e a função check_model() realiza verificações abrangentes do modelo, incluindo normalidade, heteroscedasticidade e outros diagnósticos.\n\nlibrary(performance)\n\nWarning: pacote 'performance' foi compilado no R versão 4.4.1\n\ncheck_normality(m1)\n\nOK: residuals appear as normally distributed (p = 0.878).\n\ncheck_heteroscedasticity(m1)\n\nOK: Error variance appears to be homoscedastic (p = 0.880).\n\ncheck_model(m1)\n\n\n\n\n\n\n\n\nO gráficoPosterior Predictive Check compara a densidade dos dados observados com as densidades preditas pelo modelo. As linhas azuis representam as predições do modelo e a linha verde representa os dados observados. Se as linhas preditas (azuis) estiverem próximas à linha dos dados observados (verde), isso sugere que o modelo se ajusta bem aos dados. No gráfico do exemplo, as linhas azuis estão próximas à linha verde, indicando um bom ajuste do modelo.\nO gráfico Linearity (Linearidade) exibe resíduos padronizados versus valores ajustados. A linha de referência deve ser plana e horizontal e os pontos devem estar distribuídos aleatoriamente ao redor da linha horizontal. No gráfico do exemplo, os pontos parecem estar distribuídos aleatoriamente, indicando que o pressuposto de linearidade é atendido.\nO gráfico Homogeneity of Variance (Homoscedasticidade) exibe os resíduos padronizados versus valores ajustados. A linha de referência também deve ser plana e horizontal e os resíduos devem ter variância constante em todos os níveis de valores ajustados. No gráfico do exemplo, os pontos estão distribuídos de maneira uniforme ao redor da linha, indicando homoscedasticidade.\nO gráfico Normality of Residuals (Normalidade dos Resíduos) exibe o QQ plot dos resíduos padronizados. Os pontos devem estar alinhados ao longo da linha diagonal, se os pontos seguem a linha diagonal, isso indica que os resíduos são normalmente distribuídos. No gráfico do exemplo, os pontos estão relativamente alinhados à linha, indicando que os resíduos são aproximadamente normais.\nPor fim, o gráfico Influential Observations (Observações Influentes) exibe os resíduos padronizados versus leverage (hi). As observações devem estar dentro das linhas de contorno, este gráfico ajuda a identificar observações que têm uma influência desproporcional no ajuste do modelo. No gráfico do exemplo, a maioria dos pontos está dentro das linhas de contorno, indicando que não há observações influentes significativas.\n\n\nOs gráficos de diagnóstico do exemplo indicam que o modelo ajustado atende aos pressupostos necessários para uma análise de regressão válida:\n\nLinearidade: O pressuposto de linearidade é atendido, pois os resíduos são distribuídos aleatoriamente ao redor da linha horizontal.\nHomoscedasticidade: A variância dos resíduos é constante, conforme indicado pela distribuição uniforme dos pontos.\nNormalidade dos Resíduos: Os resíduos são aproximadamente normais, conforme indicado pelo QQ plot.\nObservações Influentes: Não há observações influentes significativas que possam distorcer os resultados do modelo.\n\nEsses resultados sugerem que o modelo é bem ajustado e que as inferências feitas a partir dele são confiáveis."
  }
]
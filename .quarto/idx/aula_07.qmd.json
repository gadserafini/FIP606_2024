{"title":"Análise Estatística: Estatística inferencial - Parte 2","markdown":{"yaml":{"title":"Análise Estatística: Estatística inferencial - Parte 2","author":"Gabriel A D Serafini","format":"html","editor":"visual"},"headingText":"Análise de Variância (ANOVA)","containsRefs":false,"markdown":"\n\n\n## One-Way ANOVA\n\nA **One-Way ANOVA** (Análise de Variância de um Fator) é um teste estatístico utilizado para determinar se existem diferenças significativas entre as médias de três ou mais grupos independentes. A \"one-way\" refere-se ao fato de que há apenas uma variável independente (fator) sendo testada. Este teste é usado quando se quer comparar as médias de diferentes grupos para verificar se pelo menos um grupo difere significativamente dos outros.\n\nDesta vez iniciaremos garantindo que todos os gráficos tenham uma aparência unica ao longo do documento, para isso, configuraremos o tema para `theme_bw()` usando a função `theme_set()`.\n\n```{r}\nlibrary(tidyverse)\ntheme_set(theme_bw())\n```\n\nPara este tópico utilizamos o conjunto de dados `InsectSprays` para nossa análise. Este conjunto de dados contém informações sobre a contagem de insetos após a aplicação de diferentes sprays.\n\n```{r}\ninseticida <- InsectSprays\nhead(inseticida)\n```\n\nAntes de prosseguir com a análise, é útil entender a distribuição das observações entre os diferentes tipos de spray. Para isso, utilizamos a função `count()` do pacote `tidyverse`, que conta o número de ocorrências de cada categoria na variável `spray`.\n\n```{r}\nlibrary(tidyverse)\ninseticida |> \n  count(spray)\n```\n\nA função `count()` é usada para contar as ocorrências de valores únicos em uma coluna. No caso acima, estamos contando quantas vezes cada tipo de spray aparece no conjunto de dados `InsectSprays`.\n\nPara ter uma visão geral da contagem por tipo de spray, usamos o *boxplot* (gráfico de caixa) e *jitter* para a dispersão.\n\n```{r}\nlibrary(ggplot2)\ninseticida |>\n  ggplot(aes(x = spray, y = count))+\n  geom_boxplot()+\n  geom_jitter()+\n  theme_bw()\n```\n\nO boxplot dá indícios de que as médias C, D e E diferem das demais. Entretanto, o plot da variatiância dos dados é bem grande e com presença de outliers.\n\n```{r}\nm1 <- lm(count ~ spray,\n         data = inseticida)\nsummary(m1)\nanova(m1)\n```\n\nSegundo a one-way ANOVA, o p-valor associado ao teste F foi \\< 0.05, indicando que há uma diferença estatisticamente significativa entre pelo menos um par de grupos de spray.\n\n### Diagnóstico dos Resíduos\n\nPara garantir que o modelo ANOVA seja válido, verificamos os resíduos do modelo para normalidade e homocedasticidade. Inicialmente a normalidade dos resíduos e a homocedasticidade foram verificadas usando um histograma e um gráfico QQ, respectivamente.\n\n```{r}\nm1$residuals\nhist(m1$residuals)\nqqnorm(m1$residuals)\nqqline(m1$residuals)\n```\n\nSegundo obvervado no histograma, os residuos aparentemente seguem uma distribuição normal. Olhando o gráfico QQ os pontos extremos se distanciam em muito a linha central, o que indica não haver homocedesticidade.\n\nEntretanto, para sabermos definitivamente, de uma forma não subjetiva, se os dados atendem aos preceitos estátisticos, foram feitos o teste de Shapiro-Wilk, para verificar a normalidade e Bartlett para testarmos a homogeneidade de variância.\n\n```{r}\nshapiro.test(m1$residuals)\nbartlett.test(count ~ spray,\n              data = inseticida)\n```\n\nEm ambos os testes o p-valor foi \\< 0.05, assim os dados não apresentam normalidade e homogeneidade de variância pelo teste de Shapiro-Wilk e Bartllet, respectivamente. Destre deste preceitos estatísticos, a falta de normalidade é mais \"leve\" do que a falta de homocedasticidade.\n\nOutras funções como `check_normality()` e `check_heteroscedasticity()` do pacote `performance` são outras opções poderosas de ferramentas para verificar os pressupostos de normalidade e homocedasticidade.\n\n```{r}\nlibrary(performance)\ncheck_normality(m1)\ncheck_heteroscedasticity(m1)\n```\n\nAs funções do pacote `performance` oferecem uma saída escrita e em cores que identificam se atendeu (verde) ou não (vermelho) ao teste em que os dados foram submetidos. Essas verificações são essenciais para garantir que as inferências estatísticas sejam válidas.\n\nNo caso do exemplo, como dito anteriormente, os dados não apresentaram normalidade e homogeneidade de variância.\n\nOutra opção é a utilização do pacote `DHARMa` (Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models), ecificamente a função `simulateResiduals()`. Esta função é usada para gerar resíduos simulados a partir do modelo ajustado. Isso é feito para criar uma distribuição de referência que é usada para diagnosticar o modelo.\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(m1))\n```\n\nO gráfico da esquerda, *QQ Plot Residuals*, tem por objetivo verificar a normalidade dos resíduos. Este gráfico compara os quantis dos resíduos observados com os quantis de uma distribuição normal teórica. Os pontos no gráfico representam os resíduos simulados, e a linha diagonal representa a distribuição normal teórica. Na imagem, os pontos estão próximos da linha diagonal, indicando que os resíduos são aproximadamente normais.\n\nEsta mesma função realiza o teste de Kolmogorov-Smirnov (KS), este teste é usado para testar a hipótese de que os resíduos seguem uma distribuição normal. Um p-valor de 0.380 indica que não rejeitamos a hipótese nula de normalidade, sugerindo que os resíduos são normalmente distribuídos.\n\nJá o gráfico da direita, um *Boxplot de Resíduos vs. Valores Ajustados*, tem por objetico verificar a homocedasticidade (igualdade das variâncias) dos resíduos. Este boxplot mostra a distribuição dos resíduos simulados para diferentes valores preditos pelo modelo (valores ajustados). Neste gráfico as caixas parecem ter tamanhos muito diferentes, indicando possível heterocedasticidade.\n\nO teste de Levene, que é usado para testar a hipótese de homogeneidade das variâncias, também é aplicado ao se utilizar a função`simulateResiduals()` e significância do teste de Levene sugere que há heterocedasticidade, ou seja, a variância dos resíduos não é constante ao longo dos valores ajustados.\n\n## Transformação dos Dados\n\nQuando os dados não atendem aos pressupostos de normalidade e homocedasticidade, podemos aplicar uma transformação, como a raiz quadrada, Arco Seno, Logarítmica, Box Cox ou outros, para tentar normalizar os dados e estabilizar a variância.\n\n### Transformação - Raiz quadrada\n\nQuando temos dado de contagem geralmente se utiliza a raiz quadrada. Para isso transformamos a variável de contagem aplicando a raiz quadrada e visualizamos novamente os dados. Como no exempo:\n\n```{r}\ninseticida <- inseticida |>\n  mutate(count2 = sqrt(count))\ninseticida |>\n  ggplot(aes(x = spray, y = count2))+\n  geom_boxplot()+\n  geom_jitter()+\n  theme_bw()\n```\n\n```{r}\nm2 <- lm(count2 ~ spray,\n         data = inseticida)\nsummary(m2)\nanova(m2)\nm2$residuals\nhist(m2$residuals)\nqqnorm(m2$residuals)\nqqline(m2$residuals)\n```\n\n```{r}\nshapiro.test(m2$residuals)\nbartlett.test(count2 ~ spray,\n              data = inseticida)\n```\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(m2))\n\nlibrary(performance)\ncheck_normality(m2)\ncheck_heteroscedasticity(m2)\n```\n\nAgora os dados atendem a normalidade e homocedasticidade.\n\nemmeans mostra o intervalo de confiança\n\n```{r}\nlibrary(emmeans)\nm1_medias <- emmeans(m1, ~ spray)\nplot(m1_medias)\n```\n\n```{r}\nlibrary(multcomp)\ncld(m1_medias)\n```\n\n```{r}\nlibrary(emmeans)\nm2_medias <- emmeans(m2, ~ spray)\nplot(m2_medias)\n```\n\n```{r}\nlibrary(multcomp)\ncld(m2_medias)\n```\n\n```{r}\npwpm(m2_medias)\npwpp(m2_medias)\n\n```\n\n```{r}\npairs(m2_medias)\n```\n\npodemos aplicar de Box-Cox\n\n```{r}\nlibrary(MASS)\nb <- boxcox(lm(inseticida$count + 0.1 ~ 1))\nlambda <- b$x[which.max(b$y)]\nlambda\n```\n\n```{r}\ninseticida$count3 <- (inseticida$count^lambda-1)/lambda\ninseticida$count3\n```\n\nSe lambda for igual a 0.5 é igual a raiz quadrada\n\n```{r}\nm5 <- lm(count3 ~ spray,\n         data = inseticida)\nlibrary(DHARMa)\nplot(simulateResiduals(m5))\n\nlibrary(performance)\ncheck_normality(m5)\ncheck_heteroscedasticity(m5)\n```\n\nAlternativa, usando testes não paramétricos\n\n```{r}\nlibrary(agricolae)\nprint('-=-=-=-=-=-=- DO PRÓPRIO R -=-=-=-=-=-=-')\nkruskal.test(count ~ spray,\n             data = inseticida)\nprint('-=-=-=-=-=-=- DO PACOTE AGRICOLAE -=-=-=-=-=-=-')\nm3 <- kruskal(inseticida$count,\n        inseticida$spray,\n        group = TRUE)\nm3\n```\n\ngeneralizado é mais bonito, mais moderno, mais aceito.\n\nAlternativa usando GLMs\n\n```{r}\nm4 <- glm(count ~spray,\n          family = gaussian,\n          data = inseticida)\nsummary(m4)\nanova(m4)\nlibrary(car)\nAnova(m4)\n```\n\nTem que olhar a familia da distribuição olhando os pressupostos.\n\n```{r}\nlibrary(DHARMa)\nm5 <- glm(count ~spray,\n          family = poisson,\n          data = inseticida)\nsummary(m5)\nAnova(m5)\nplot(simulateResiduals(m5))\n```\n\n```{r}\nm5_medias <- emmeans(m5, ~ spray,\n                     type = 'response')\nlibrary(multcomp)\nlibrary(multcompView)\ncld(m5_medias)\n```\n\nOutro conjunto de dados two-way anova - ANOVA fatorial\n\n```{r}\nlibrary(gsheet)\nli <- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=2023059672\")\n\nhead(li)\n```\n\n```{r}\nlibrary(ggplot2)\nli |>\n  ggplot(aes(factor(dose),severity, color = factor(dose)))+\n  geom_jitter(width = 0.1)+\n  facet_wrap(~treat)+\n  theme_bw()\n```\n\n```{r}\nli |>\n  ggplot(aes(treat ,severity, color = factor(dose)))+\n  geom_jitter(width = 0.1)\n```\n\nModelo fatoral - Para DIC\n\n```{r}\nmf <- lm(severity ~ treat*factor(dose),\n         data = li)\nmf\nanova(mf)\n```\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(mf))\n```\n\n```{r}\nlibrary(performance)\ncheck_normality(mf)\ncheck_homogeneity(mf)\n```\n\nO cld, do pacote multcomp, coloca as letras.\n\n```{r}\nmf_medias <- emmeans(mf, ~ treat | dose)\nmf_medias\n```\n\n```{r}\nlibrary(multcomp)\nmf_medias <- emmeans(mf, ~ dose | treat)\ncld(mf_medias)\n```\n","srcMarkdownNoYaml":"\n\n# Análise de Variância (ANOVA)\n\n## One-Way ANOVA\n\nA **One-Way ANOVA** (Análise de Variância de um Fator) é um teste estatístico utilizado para determinar se existem diferenças significativas entre as médias de três ou mais grupos independentes. A \"one-way\" refere-se ao fato de que há apenas uma variável independente (fator) sendo testada. Este teste é usado quando se quer comparar as médias de diferentes grupos para verificar se pelo menos um grupo difere significativamente dos outros.\n\nDesta vez iniciaremos garantindo que todos os gráficos tenham uma aparência unica ao longo do documento, para isso, configuraremos o tema para `theme_bw()` usando a função `theme_set()`.\n\n```{r}\nlibrary(tidyverse)\ntheme_set(theme_bw())\n```\n\nPara este tópico utilizamos o conjunto de dados `InsectSprays` para nossa análise. Este conjunto de dados contém informações sobre a contagem de insetos após a aplicação de diferentes sprays.\n\n```{r}\ninseticida <- InsectSprays\nhead(inseticida)\n```\n\nAntes de prosseguir com a análise, é útil entender a distribuição das observações entre os diferentes tipos de spray. Para isso, utilizamos a função `count()` do pacote `tidyverse`, que conta o número de ocorrências de cada categoria na variável `spray`.\n\n```{r}\nlibrary(tidyverse)\ninseticida |> \n  count(spray)\n```\n\nA função `count()` é usada para contar as ocorrências de valores únicos em uma coluna. No caso acima, estamos contando quantas vezes cada tipo de spray aparece no conjunto de dados `InsectSprays`.\n\nPara ter uma visão geral da contagem por tipo de spray, usamos o *boxplot* (gráfico de caixa) e *jitter* para a dispersão.\n\n```{r}\nlibrary(ggplot2)\ninseticida |>\n  ggplot(aes(x = spray, y = count))+\n  geom_boxplot()+\n  geom_jitter()+\n  theme_bw()\n```\n\nO boxplot dá indícios de que as médias C, D e E diferem das demais. Entretanto, o plot da variatiância dos dados é bem grande e com presença de outliers.\n\n```{r}\nm1 <- lm(count ~ spray,\n         data = inseticida)\nsummary(m1)\nanova(m1)\n```\n\nSegundo a one-way ANOVA, o p-valor associado ao teste F foi \\< 0.05, indicando que há uma diferença estatisticamente significativa entre pelo menos um par de grupos de spray.\n\n### Diagnóstico dos Resíduos\n\nPara garantir que o modelo ANOVA seja válido, verificamos os resíduos do modelo para normalidade e homocedasticidade. Inicialmente a normalidade dos resíduos e a homocedasticidade foram verificadas usando um histograma e um gráfico QQ, respectivamente.\n\n```{r}\nm1$residuals\nhist(m1$residuals)\nqqnorm(m1$residuals)\nqqline(m1$residuals)\n```\n\nSegundo obvervado no histograma, os residuos aparentemente seguem uma distribuição normal. Olhando o gráfico QQ os pontos extremos se distanciam em muito a linha central, o que indica não haver homocedesticidade.\n\nEntretanto, para sabermos definitivamente, de uma forma não subjetiva, se os dados atendem aos preceitos estátisticos, foram feitos o teste de Shapiro-Wilk, para verificar a normalidade e Bartlett para testarmos a homogeneidade de variância.\n\n```{r}\nshapiro.test(m1$residuals)\nbartlett.test(count ~ spray,\n              data = inseticida)\n```\n\nEm ambos os testes o p-valor foi \\< 0.05, assim os dados não apresentam normalidade e homogeneidade de variância pelo teste de Shapiro-Wilk e Bartllet, respectivamente. Destre deste preceitos estatísticos, a falta de normalidade é mais \"leve\" do que a falta de homocedasticidade.\n\nOutras funções como `check_normality()` e `check_heteroscedasticity()` do pacote `performance` são outras opções poderosas de ferramentas para verificar os pressupostos de normalidade e homocedasticidade.\n\n```{r}\nlibrary(performance)\ncheck_normality(m1)\ncheck_heteroscedasticity(m1)\n```\n\nAs funções do pacote `performance` oferecem uma saída escrita e em cores que identificam se atendeu (verde) ou não (vermelho) ao teste em que os dados foram submetidos. Essas verificações são essenciais para garantir que as inferências estatísticas sejam válidas.\n\nNo caso do exemplo, como dito anteriormente, os dados não apresentaram normalidade e homogeneidade de variância.\n\nOutra opção é a utilização do pacote `DHARMa` (Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models), ecificamente a função `simulateResiduals()`. Esta função é usada para gerar resíduos simulados a partir do modelo ajustado. Isso é feito para criar uma distribuição de referência que é usada para diagnosticar o modelo.\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(m1))\n```\n\nO gráfico da esquerda, *QQ Plot Residuals*, tem por objetivo verificar a normalidade dos resíduos. Este gráfico compara os quantis dos resíduos observados com os quantis de uma distribuição normal teórica. Os pontos no gráfico representam os resíduos simulados, e a linha diagonal representa a distribuição normal teórica. Na imagem, os pontos estão próximos da linha diagonal, indicando que os resíduos são aproximadamente normais.\n\nEsta mesma função realiza o teste de Kolmogorov-Smirnov (KS), este teste é usado para testar a hipótese de que os resíduos seguem uma distribuição normal. Um p-valor de 0.380 indica que não rejeitamos a hipótese nula de normalidade, sugerindo que os resíduos são normalmente distribuídos.\n\nJá o gráfico da direita, um *Boxplot de Resíduos vs. Valores Ajustados*, tem por objetico verificar a homocedasticidade (igualdade das variâncias) dos resíduos. Este boxplot mostra a distribuição dos resíduos simulados para diferentes valores preditos pelo modelo (valores ajustados). Neste gráfico as caixas parecem ter tamanhos muito diferentes, indicando possível heterocedasticidade.\n\nO teste de Levene, que é usado para testar a hipótese de homogeneidade das variâncias, também é aplicado ao se utilizar a função`simulateResiduals()` e significância do teste de Levene sugere que há heterocedasticidade, ou seja, a variância dos resíduos não é constante ao longo dos valores ajustados.\n\n## Transformação dos Dados\n\nQuando os dados não atendem aos pressupostos de normalidade e homocedasticidade, podemos aplicar uma transformação, como a raiz quadrada, Arco Seno, Logarítmica, Box Cox ou outros, para tentar normalizar os dados e estabilizar a variância.\n\n### Transformação - Raiz quadrada\n\nQuando temos dado de contagem geralmente se utiliza a raiz quadrada. Para isso transformamos a variável de contagem aplicando a raiz quadrada e visualizamos novamente os dados. Como no exempo:\n\n```{r}\ninseticida <- inseticida |>\n  mutate(count2 = sqrt(count))\ninseticida |>\n  ggplot(aes(x = spray, y = count2))+\n  geom_boxplot()+\n  geom_jitter()+\n  theme_bw()\n```\n\n```{r}\nm2 <- lm(count2 ~ spray,\n         data = inseticida)\nsummary(m2)\nanova(m2)\nm2$residuals\nhist(m2$residuals)\nqqnorm(m2$residuals)\nqqline(m2$residuals)\n```\n\n```{r}\nshapiro.test(m2$residuals)\nbartlett.test(count2 ~ spray,\n              data = inseticida)\n```\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(m2))\n\nlibrary(performance)\ncheck_normality(m2)\ncheck_heteroscedasticity(m2)\n```\n\nAgora os dados atendem a normalidade e homocedasticidade.\n\nemmeans mostra o intervalo de confiança\n\n```{r}\nlibrary(emmeans)\nm1_medias <- emmeans(m1, ~ spray)\nplot(m1_medias)\n```\n\n```{r}\nlibrary(multcomp)\ncld(m1_medias)\n```\n\n```{r}\nlibrary(emmeans)\nm2_medias <- emmeans(m2, ~ spray)\nplot(m2_medias)\n```\n\n```{r}\nlibrary(multcomp)\ncld(m2_medias)\n```\n\n```{r}\npwpm(m2_medias)\npwpp(m2_medias)\n\n```\n\n```{r}\npairs(m2_medias)\n```\n\npodemos aplicar de Box-Cox\n\n```{r}\nlibrary(MASS)\nb <- boxcox(lm(inseticida$count + 0.1 ~ 1))\nlambda <- b$x[which.max(b$y)]\nlambda\n```\n\n```{r}\ninseticida$count3 <- (inseticida$count^lambda-1)/lambda\ninseticida$count3\n```\n\nSe lambda for igual a 0.5 é igual a raiz quadrada\n\n```{r}\nm5 <- lm(count3 ~ spray,\n         data = inseticida)\nlibrary(DHARMa)\nplot(simulateResiduals(m5))\n\nlibrary(performance)\ncheck_normality(m5)\ncheck_heteroscedasticity(m5)\n```\n\nAlternativa, usando testes não paramétricos\n\n```{r}\nlibrary(agricolae)\nprint('-=-=-=-=-=-=- DO PRÓPRIO R -=-=-=-=-=-=-')\nkruskal.test(count ~ spray,\n             data = inseticida)\nprint('-=-=-=-=-=-=- DO PACOTE AGRICOLAE -=-=-=-=-=-=-')\nm3 <- kruskal(inseticida$count,\n        inseticida$spray,\n        group = TRUE)\nm3\n```\n\ngeneralizado é mais bonito, mais moderno, mais aceito.\n\nAlternativa usando GLMs\n\n```{r}\nm4 <- glm(count ~spray,\n          family = gaussian,\n          data = inseticida)\nsummary(m4)\nanova(m4)\nlibrary(car)\nAnova(m4)\n```\n\nTem que olhar a familia da distribuição olhando os pressupostos.\n\n```{r}\nlibrary(DHARMa)\nm5 <- glm(count ~spray,\n          family = poisson,\n          data = inseticida)\nsummary(m5)\nAnova(m5)\nplot(simulateResiduals(m5))\n```\n\n```{r}\nm5_medias <- emmeans(m5, ~ spray,\n                     type = 'response')\nlibrary(multcomp)\nlibrary(multcompView)\ncld(m5_medias)\n```\n\nOutro conjunto de dados two-way anova - ANOVA fatorial\n\n```{r}\nlibrary(gsheet)\nli <- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=2023059672\")\n\nhead(li)\n```\n\n```{r}\nlibrary(ggplot2)\nli |>\n  ggplot(aes(factor(dose),severity, color = factor(dose)))+\n  geom_jitter(width = 0.1)+\n  facet_wrap(~treat)+\n  theme_bw()\n```\n\n```{r}\nli |>\n  ggplot(aes(treat ,severity, color = factor(dose)))+\n  geom_jitter(width = 0.1)\n```\n\nModelo fatoral - Para DIC\n\n```{r}\nmf <- lm(severity ~ treat*factor(dose),\n         data = li)\nmf\nanova(mf)\n```\n\n```{r}\nlibrary(DHARMa)\nplot(simulateResiduals(mf))\n```\n\n```{r}\nlibrary(performance)\ncheck_normality(mf)\ncheck_homogeneity(mf)\n```\n\nO cld, do pacote multcomp, coloca as letras.\n\n```{r}\nmf_medias <- emmeans(mf, ~ treat | dose)\nmf_medias\n```\n\n```{r}\nlibrary(multcomp)\nmf_medias <- emmeans(mf, ~ dose | treat)\ncld(mf_medias)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"aula_07.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","editor":"visual","theme":{"light":"pulse"},"title":"Análise Estatística: Estatística inferencial - Parte 2","author":"Gabriel A D Serafini"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}